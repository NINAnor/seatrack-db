<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.9.2-alpha" last-position="119,824" last-zoom="0.7"
	 default-owner="postgres">
<role name="seatrack_reader">
</role>

<role name="seatrack_writer">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="admin"
      superuser="true"
      createrole="true">
	<prepended-sql><![CDATA[
]]></prepended-sql>
</role>

<role name="testreader"
      inherit="true"
      login="true"
      encrypted="true"
      password="testreader">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="shinyuser"
      inherit="true"
      login="true"
      encrypted="true"
      password="shinyuser">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="seatrack_metadata_writer">
	<roles names="seatrack_writer" role-type="refer" />
</role>

<role name="testwriter"
      login="true"
      encrypted="true"
      password="testwriter">
	<roles names="seatrack_metadata_writer,seatrack_writer" role-type="refer" />
</role>

<role name="jens_astrom"
      inherit="true"
      login="true"
      encrypted="true"
      password="jens_astrom">
	<roles names="admin" role-type="refer" />
</role>

<role name="vegard_braathen"
      inherit="true"
      login="true"
      encrypted="true"
      password="vegard_braathen">
	<roles names="seatrack_writer" role-type="refer" />
</role>

<role name="halfdan_helgason"
      inherit="true"
      login="true"
      encrypted="true"
      password="halfdan_helgason">
</role>

<role name="borge_moe"
      inherit="true"
      login="true"
      encrypted="true"
      password="borge_moe">
	<roles names="seatrack_writer" role-type="refer" />
</role>

<role name="hallvard_strom"
      inherit="true"
      login="true"
      encrypted="true"
      password="hallvard_strom">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="sebastien_descamps"
      inherit="true"
      login="true"
      encrypted="true"
      password="sebastien_descamps">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="benjamin_merkel"
      inherit="true"
      login="true"
      encrypted="true"
      password="benjamin_merkel">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="conrad_helgeland"
      inherit="true"
      login="true"
      encrypted="true"
      password="conrad_helgeland">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="per_fauchald"
      inherit="true"
      login="true"
      encrypted="true"
      password="per_fauchald">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="arnaud_tarroux"
      inherit="true"
      login="true"
      encrypted="true"
      password="arnaud_tarroux">
	<roles names="seatrack_reader" role-type="refer" />
</role>

<role name="pure_ftp"
      login="true"
      encrypted="true"
      password="aRw8GEF6">
</role>

<role name="restricted">
	<roles names="pure_ftp" role-type="admin" />
</role>

<tablespace name="temp" directory="'/data'">
	<role name="postgres"/>
</tablespace>

<database name="seatrack" encoding="UTF8" template="template0" lc-collate="en_US.UTF-8" lc-ctype="en_US.UTF-8" is-template="false" allow-conns="true" append-at-eod="true" prepend-at-bod="true">
	<role name="admin"/>
	<appended-sql><![CDATA[-----------usage permissions
GRANT USAGE ON SCHEMA metadata, loggers, positions, views, imports, individuals, functions
TO seatrack_reader, seatrack_writer, seatrack_metadata_writer;

----------Reader permissions
GRANT SELECT
ON ALL TABLES IN SCHEMA loggers
TO seatrack_reader;

GRANT SELECT
ON ALL TABLES IN SCHEMA metadata
TO seatrack_reader;

GRANT SELECT
ON ALL TABLES IN SCHEMA individuals
TO seatrack_reader;

GRANT SELECT
ON ALL TABLES IN SCHEMA views
TO seatrack_reader;

GRANT SELECT
ON ALL TABLES IN SCHEMA positions
TO seatrack_reader;


GRANT SELECT, INSERT, UPDATE, DELETE, TRIGGER
ON ALL TABLES IN SCHEMA metadata
TO seatrack_metadata_writer;

-------Writer permissions
GRANT SELECT, INSERT, UPDATE, DELETE, TRIGGER
ON ALL TABLES IN SCHEMA loggers
TO seatrack_writer;

GRANT SELECT, INSERT, UPDATE, DELETE, TRIGGER
ON ALL TABLES IN SCHEMA individuals
TO seatrack_writer;

GRANT SELECT, INSERT, UPDATE, DELETE, TRIGGER
ON ALL TABLES IN SCHEMA positions
TO seatrack_writer;

GRANT SELECT, INSERT, UPDATE, DELETE, TRIGGER
ON ALL TABLES IN SCHEMA activity
TO seatrack_writer;

GRANT SELECT, INSERT, UPDATE, DELETE, TRIGGER
ON ALL TABLES IN SCHEMA imports
TO seatrack_writer;

GRANT SELECT
ON ALL TABLES IN SCHEMA views
TO seatrack_reader;

GRANT SELECT
ON ALL TABLES IN SCHEMA metadata
TO seatrack_reader;

----------Sequence permissions
GRANT USAGE 
ON ALL SEQUENCES IN SCHEMA metadata 
TO seatrack_writer, seatrack_reader;

GRANT USAGE 
ON ALL SEQUENCES IN SCHEMA loggers 
TO seatrack_writer, seatrack_reader;

GRANT USAGE 
ON ALL SEQUENCES IN SCHEMA individuals 
TO seatrack_writer, seatrack_reader;

GRANT USAGE 
ON ALL SEQUENCES IN SCHEMA imports
TO seatrack_writer, seatrack_reader;

GRANT USAGE 
ON ALL SEQUENCES IN SCHEMA positions 
TO seatrack_writer,  seatrack_reader;



]]></appended-sql>
	<prepended-sql><![CDATA[CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "adminpack";
CREATE EXTENSION IF NOT EXISTS "tsm_system_rows";]]></prepended-sql>
</database>

<schema name="public" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<schema name="config" rect-visible="true" fill-color="#e1e1e1">
	<role name="admin"/>
</schema>

<schema name="metadata" rect-visible="true" fill-color="#0000ff">
	<role name="admin"/>
</schema>

<schema name="loggers" rect-visible="true" fill-color="#55aa00">
	<role name="admin"/>
</schema>

<table name="logger_info">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="992.308" y="80"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="logger_id" not-null="true">
		<type name="serial" length="80"/>
	</column>
	<column name="logger_serial_no" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="logger_model" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="producer" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="production_year" not-null="true">
		<type name="smallint" length="0"/>
	</column>
	<column name="project">
		<type name="text" length="0"/>
	</column>
	<constraint name="logger_info_pk" type="pk-constr" table="loggers.logger_info">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="logger_id_unique" type="uq-constr" table="loggers.logger_info">
		<columns names="logger_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="logger_mod_serial_uq" type="uq-constr" table="loggers.logger_info">
		<columns names="logger_model,logger_serial_no" ref-type="src-columns"/>
	</constraint>
</table>

<table name="logger_producers">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="80" y="80"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="producer" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="logger_producers_pk" type="pk-constr" table="metadata.logger_producers">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="producer_unique_constraint" type="uq-constr" table="metadata.logger_producers">
		<columns names="producer" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•producer⸣
•testproducer⸣
•Migrate Technology⸣
•Biotrack⸣
•BAS⸣
•LOTEK⸣
•UNKNOWN]]>
	</initial-data>
</table>

<table name="logger_models">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="89.0909" y="207.273"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="producer" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="model" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="logger_models_pk" type="pk-constr" table="metadata.logger_models">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="model_unique" type="uq-constr" table="metadata.logger_models">
		<columns names="producer,model" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•producer•model⸣
•testproducer•testmodel⸣
•Migrate Technology•c330⸣
•Migrate Technology•f100⸣
•Migrate Technology•c250⸣
•Migrate Technology•c65⸣
•Migrate Technology•w65⸣
•Biotrack•mk3005⸣
•Biotrack•mk3006⸣
•Biotrack•mk4083⸣
•Biotrack•mk4093⸣
•BAS•mk9⸣
•BAS•mk13⸣
•BAS•mk14⸣
•BAS•mk15⸣
•BAS•mk18⸣
•BAS•mk4⸣
•LOTEK•LAT⸣
•UNKNOWN•other]]>
	</initial-data>
</table>

<table name="logging_modes">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="85.4545" y="387.273"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="mode" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="clipped_lightrange">
		<type name="boolean" length="0"/>
	</column>
	<constraint name="logging_modes_pk" type="pk-constr" table="metadata.logging_modes">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="logging_modes_unique" type="uq-constr" table="metadata.logging_modes">
		<columns names="mode" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•mode•clipped_lightrange⸣
•testmode•⸣
•1•T⸣
•2•F⸣
•3•⸣
•4•⸣
•5•⸣
•6•⸣
•7•⸣
•8•⸣
•9•⸣
•10•⸣
•11•⸣
•12•⸣
•13•⸣
•14•⸣
•15•]]>
	</initial-data>
</table>

<table name="people">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="100" y="540"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="person_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="abrev_name" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="people_pk" type="pk-constr" table="metadata.people">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="names_unique" type="uq-constr" table="metadata.people">
		<columns names="name" ref-type="src-columns"/>
	</constraint>
	<constraint name="person_id_uq" type="uq-constr" table="metadata.people">
		<columns names="person_id" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[name•abrev_name•id•person_id⸣
Alexei Ezhov•A_Ezhov••⸣
Arild Breistøl•A_Breistøl••⸣
Arne Follestad•A_Follestad••⸣
Arnt Kvinnesland•A_Kvinnesland••⸣
Oskar Bjørnstad•O_Bjørnstad••⸣
Bergur Olsen•B_Olsen••⸣
Børge Moe•B_Moe••⸣
Olivier Chastel•O_Chastel••⸣
Dorothee Ehrlich•D_Ehrlich••⸣
Ekaterina Tolmacheva•E_Tolmacheva••⸣
Erlend Lorentzen•E_Lorentzen••⸣
Erpur Snær Hansen•ES_Hansen••⸣
Francis Daunt•F_Daunt••⸣
Geir Helge Systad•GH_Systad••⸣
Grigori Tertitski•G_Tertitski••⸣
Hallvard Strøm•H_Strøm••⸣
Ingar Støyle Bringsvor•IS_Bringsvor••⸣
Ingve Birkeland•I_Birkeland••⸣
Jan Ove Bustnes•JO_Bustnes••⸣
Johannis Danielsen•J_Danielsen••⸣
Jón Einar Jónsson•JE_Jónsson••⸣
Kjell Einar Erikstad•KE_Erikstad••⸣
Magdalene Langset•M_Langset••⸣
Maria Gavrilo•M_Gavrilo••⸣
Morten Helberg•M_Helberg••⸣
Paul Thompson•P_Thompson••⸣
Runar Jåbekk•R_Jåbekk••⸣
Sebastien Descamps•S_Descamps••⸣
Signe Christensen-Dalsgaard•S_Christensen-Dalsgaard••⸣
Sunna Bjork Ragnarsdottir•SB_Ragnarsdottir••⸣
Gunnar Thor Hallgrimsson•GT_Hallgrimsson••⸣
Svein-Håkon Lorentsen•SH_Lorentsen••⸣
Olav Runde•O_Runde••⸣
Sveinn Are Hanssen•SA_Hanssen••⸣
Thorkell Lindberg Thorarinsson•TL_Thórarinsson••⸣
Tycho Anker-Nilssen•T_Anker-Nilssen••⸣
Vegard Finset•V_Finset••⸣
Vegard Sandøy Bråthen•VS_Bråthen••⸣
Per Fauchald•P_Fauchald••⸣
Hálfdán Helgi Helgason•HH_Helgason••⸣
Benjamin Merkel•B_Merkel••⸣
Tim Guilford•T_Guilford••⸣
Morten Frederiksen•M_Frederiksen••⸣
Lorrain Chivers•L_Chivers••⸣
Sara Wanless•S_Wanless••⸣
Maria Bogdanova•M_Bogdanova••⸣
Jacob•J_González-Solís••⸣
Deryk Shaw•D_Shaw••⸣
Yuri V Krasnov•Y_Krasnov••⸣
Thierry Boulinier•T_Boulinier••⸣
Sabrina Tartu•S_Tartu••⸣
Tone Reiertsen•T_Reiertsen••⸣
Aurore Ponchon•A_Ponchon••⸣
Michael P Harris•MP_Harris••⸣
Celine Clement Chastel•CC_Chastel••⸣
Rob T Barret•RT_Barret••⸣
Pierre Blevin•P_Blevin••⸣
Frederic Angelier•F_Angelier••⸣
Jens Åström•J_Åström••]]>
	</initial-data>
</table>

<table name="allocation">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="960" y="720"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id">
		<type name="integer" length="0"/>
	</column>
	<column name="logger_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="intended_species">
		<type name="text" length="0"/>
	</column>
	<column name="intended_location">
		<type name="text" length="0"/>
	</column>
	<column name="intended_deployer">
		<type name="text" length="0"/>
	</column>
	<constraint name="allocation_pk" type="pk-constr" table="loggers.allocation">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="allocation_session_id_unique" type="uq-constr" table="loggers.allocation">
		<columns names="session_id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="logging_session">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="971.394" y="1028.6"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id">
		<type name="integer" length="0"/>
	</column>
	<column name="logger_id">
		<type name="integer" length="40"/>
	</column>
	<column name="deployment_id" default-value="NULL">
		<type name="integer" length="0"/>
	</column>
	<column name="retrieval_id" default-value="NULL">
		<type name="integer" length="0"/>
	</column>
	<column name="active" default-value="TRUE">
		<type name="boolean" length="0"/>
	</column>
	<column name="colony">
		<type name="text" length="0"/>
	</column>
	<column name="species">
		<type name="text" length="0"/>
	</column>
	<column name="year_tracked">
		<type name="text" length="0"/>
	</column>
	<column name="individ_id">
		<type name="uuid" length="0"/>
	</column>
	<column name="last_updated">
		<type name="timestamp" length="0"/>
	</column>
	<column name="updated_by">
		<type name="text" length="0"/>
	</column>
	<constraint name="logging_session_pk" type="pk-constr" table="loggers.logging_session">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="logging_session_session_id_unique" type="uq-constr" table="loggers.logging_session">
		<columns names="session_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="retrieval_id" type="uq-constr" table="loggers.logging_session">
		<columns names="retrieval_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="deployment_id" type="uq-constr" table="loggers.logging_session">
		<columns names="deployment_id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="species">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="496.923" y="826.154"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="species_name_eng" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="species_name_latin" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="species_pk" type="pk-constr" table="metadata.species">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="species_name_unique" type="uq-constr" table="metadata.species">
		<columns names="species_name_eng" ref-type="src-columns"/>
	</constraint>
	<constraint name="species_name_latin_unique" type="uq-constr" table="metadata.species">
		<columns names="species_name_latin" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[species_name_eng•species_name_latin•id⸣
Common guillemot•Uria aalge•⸣
Brünnich's guillemot•Uria lomvia•⸣
Little auk•Alle alle•⸣
Atlantic puffin•Fratercula arctica•⸣
Black-legged kittiwake•Rissa tridactyla•⸣
Northern fulmar•Fulmarus glacialis•⸣
Lesser black-backed gull•Larus fuscus•⸣
Herring gull•Larus argentatus•⸣
Glaucous gull•Larus hyperboreus•⸣
European shag•Phalacrocorax aristotelis•⸣
Common eider•Somateria mollissima•⸣
testspecies•Testus specius•]]>
	</initial-data>
</table>

<extension name="postgis">
</extension>

<table name="location">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="60" y="1020"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="location_name" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="colony_int_name" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="colony_nat_name" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="lat">
		<type name="double precision" length="0"/>
	</column>
	<column name="lon">
		<type name="double precision" length="0"/>
	</column>
	<column name="geom">
		<type name="geometry" length="0" spatial-type="POINT" variation="0" srid="4326"/>
	</column>
	<constraint name="location_pk" type="pk-constr" table="metadata.location">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="location_unique" type="uq-constr" table="metadata.location">
		<columns names="location_name" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[location_name•colony_int_name•colony_nat_name•lat•lon⸣
Ærvikurbjarg•Langanes and Skjalfandi•Langanes and Skjálfandi•70.92056•-8.71778⸣
Agneskjær•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Alkefjellet•Alkefjellet•Alkefjellet•60.66761•4.74869⸣
Anda•Anda•Anda•62.40000•5.62000⸣
Båly•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Bjørndalen•Isfjorden•Isfjorden•74.36450•19.14751⸣
Bjørnøya•Bear Island•Bjørnøya•69.06500•15.17000⸣
Cape Flora•Franz Josef Land•Zemlya Frantsa-Iosifa•64.74000•10.77000⸣
Cape Krutik•Cape Krutik•Mys Krutik•78.94400•12.43900⸣
Diabas•Isfjorden•Isfjorden•74.36450•19.14751⸣
Dolgaya Bay•Solovetsky archipelago•Solovetskiye Ostrova•70.35833•21.39833⸣
Eastern Bolshie Oranskye•Oranskie Islands•Oranskie Ostrova•78.90000•12.21667⸣
Ellefsnyken•Rost•Røst•74.23110•19.10320⸣
Evjebukta•Bear Island•Bjørnøya•69.06500•15.17000⸣
Eyjafjordur•Eyjafjordur•Eyjafjörður•67.44700•11.91400⸣
Eynhallow•Eynhallow•Eynhallow•65.20200•10.99500⸣
Feiringfjellet•Kongsfjorden•Kongsfjorden•69.63505•18.84826⸣
Fontur•Langanes and Skjalfandi•Langanes and Skjálfandi•70.92056•-8.71778⸣
Gardahraun•Reykjanes•Reykjanes•78.21500•15.27000⸣
Gassadalur•Faroe Islands•Føroyar•66.58500•12.22900⸣
Glyvursnes•Faroe Islands•Føroyar•66.58500•12.22900⸣
Gorodetskiy Kape•Cape Gorodetskiy•Gorodetskye ptich`i bazary•79.00500•12.41100⸣
Grimsey•Grimsey•Grímsey•67.50500•12.07900⸣
Grindavik•Reykjanes•Reykjanes•78.21500•15.27000⸣
Grindøya•Grindoya•Grindøya•74.34257•19.10117⸣
Grumant•Isfjorden•Isfjorden•74.36450•19.14751⸣
Hafnarholmi•Hafnarholmi•Hafnarhólmi•65.54•-13.78⸣
Hårkniba•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Havnardalur•Faroe Islands•Føroyar•66.58500•12.22900⸣
Hernyken•Rost•Røst•74.23110•19.10320⸣
Hillesund•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Hjallsey•Breidafjordur•Breiðafjörður•78.36400•16.14100⸣
Hornøya•Hornoya•Hornøya•74.35122•19.10070⸣
Horsvær•Horsvaer•Horsvær•74.36585•19.14922⸣
Husholmen•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Isle of May•Isle of May•Isle of May•65.32000•11.63000⸣
Jan Mayen•Jan Mayen•Jan Mayen•74.34665•19.09100⸣
Jarsteinen•Jarsteinen•Jarsteinen•70.38333•31.15000⸣
Kalsvikholmen•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Kapp Kolthoff•Bear Island•Bjørnøya•69.06500•15.17000⸣
Kårøy•Rost•Røst•74.23110•19.10320⸣
Keila•Hjelmsoya•Hjelmsøya•74.35559•19.11467⸣
Kirkjubøholmur•Faroe Islands•Føroyar•66.58500•12.22900⸣
Kjorten•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Kongsfjorden•Kongsfjorden•Kongsfjorden•69.63505•18.84826⸣
Krægan•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Krykkjedamdalen•Bear Island•Bjørnøya•69.06500•15.17000⸣
Krykkjefjellet•Kongsfjorden•Kongsfjorden•69.63505•18.84826⸣
Laksmannen•Hjelmsoya•Hjelmsøya•74.35559•19.11467⸣
Lamba grotbrot•Faroe Islands•Føroyar•66.58500•12.22900⸣
Landey•Breidafjordur•Breiðafjörður•78.36400•16.14100⸣
Lauholmen•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Leiholmen•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Lemmingsvær•Lemmingsvaer•Lemmingsvær•71.11291•24.73238⸣
Leynavatni•Faroe Islands•Føroyar•66.58500•12.22900⸣
Likkudalur•Faroe Islands•Føroyar•66.58500•12.22900⸣
Lille Einerholmen•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Lille Feitnakken•Bear Island•Bjørnøya•69.06500•15.17000⸣
Lille Kamøya•Hjelmsoya•Hjelmsøya•74.35559•19.11467⸣
Litsky Maly Island•Seven Islands•Sem' Ostrovov•78.89700•12.19300⸣
Lonin•Faroe Islands•Føroyar•66.58500•12.22900⸣
Lyngøya•Hordaland•Hordaland•74.34703•19.09058⸣
Mandalselva Kastellet•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Matmorstua•Loppa•Loppa•71.10927•24.74736⸣
Mellom Lille Feitnakken og Feitnakken•Bear Island•Bjørnøya•69.06500•15.17000⸣
Melrakkaey•Melrakkaey•Melrakkaey•78.17400•15.12900⸣
Merra•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Migade•Bear Island•Bjørnøya•69.06500•15.17000⸣
Migande N•Bear Island•Bjørnøya•69.06500•15.17000⸣
Mittinga•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Nordre Krægan•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
NW Sennaya island•Solovetsky archipelago•Solovetskiye Ostrova•70.35833•21.39833⸣
Olavskjær•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Ossian Sars•Kongsfjorden•Kongsfjorden•69.63505•18.84826⸣
Østre Gunningsholme•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Ostrov Bolshoy Zelenets•Seven Islands•Sem' Ostrovov•78.89700•12.19300⸣
Papey•Papey•Papey•67.42700•11.88400⸣
Parusnyi island•Solovetsky archipelago•Solovetskiye Ostrova•70.35833•21.39833⸣
Revdalen•Bear Island•Bjørnøya•69.06500•15.17000⸣
Rif•Breidafjordur•Breiðafjörður•78.36400•16.14100⸣
Rubini•Franz Josef Land•Zemlya Frantsa-Iosifa•64.74000•10.77000⸣
Runde•Runde and Aalesund•Runde and Ålesund•62.47111•6.12861⸣
Russehamna•Bear Island•Bjørnøya•69.06500•15.17000⸣
Sakhanina Cape•Cape Sakhanin•Mys Sakhanina•69.03100•16.90500⸣
Saltvik•Langanes and Skjalfandi•Langanes and Skjálfandi•70.92056•-8.71778⸣
Sandavagur litla grotbroti•Faroe Islands•Føroyar•66.58500•12.22900⸣
Sandavagur stora grotbroti•Faroe Islands•Føroyar•66.58500•12.22900⸣
Sandavagur timburhandilin•Faroe Islands•Føroyar•66.58500•12.22900⸣
Sånumstranda•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Selvær•Selvaer•Selvær•74.34806•19.09142⸣
Sennaya island•Solovetsky archipelago•Solovetskiye Ostrova•70.35833•21.39833⸣
Sklinna•Sklinna•Sklinna•74.50250•18.95556⸣
Skoruvikurbjarg•Langanes and Skjalfandi•Langanes and Skjálfandi•70.92056•-8.71778⸣
Skugvoy•Faroe Islands•Føroyar•66.58500•12.22900⸣
Småholmane•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Småskjæran•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Sør-Gjæslingan•Sklinna•Sklinna•74.50250•18.95556⸣
Stakksey•Breidafjordur•Breiðafjörður•78.36400•16.14100⸣
Steinsvågen•Runde and Aalesund•Runde and Ålesund•62.47111•6.12861⸣
Stora Dimun•Faroe Islands•Føroyar•66.58500•12.22900⸣
Store Torungen•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Store Vengelsholmen•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Storøy•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Storøytåa•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Storskjær•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
Sundi•Faroe Islands•Føroyar•66.58500•12.22900⸣
Svarthellaren•Loppa•Loppa•71.10927•24.74736⸣
Sydrugøtu grotbrot•Faroe Islands•Føroyar•66.58500•12.22900⸣
Sydrugøtu waterfront•Faroe Islands•Føroyar•66.58500•12.22900⸣
Tikhaya Bay•Franz Josef Land•Zemlya Frantsa-Iosifa•64.74000•10.77000⸣
Veshnyak Island•Seven Islands•Sem' Ostrovov•78.89700•12.19300⸣
Vestmanna•Faroe Islands•Føroyar•66.58500•12.22900⸣
Vestre Røysa•Mandal and Lindesnes•Mandal and Lindesnes•70.84875•23.06400⸣
testlocation•testcolony•testcolonü•58.00528•7.44306]]>
	</initial-data>
</table>

<table name="deployment">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="980" y="1580"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="deployment_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="logger_id" not-null="true">
		<type name="integer" length="80"/>
	</column>
	<column name="individ_id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="logger_fate">
		<type name="text" length="0"/>
	</column>
	<column name="deployment_species">
		<type name="text" length="0"/>
	</column>
	<column name="deployment_location" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="deployment_date" not-null="true">
		<type name="date" length="0"/>
	</column>
	<column name="logger_mount_method">
		<type name="text" length="0"/>
	</column>
	<constraint name="deployment_pk" type="pk-constr" table="loggers.deployment">
		<columns names="id,deployment_date" ref-type="src-columns"/>
	</constraint>
	<constraint name="deployment_id_unique" type="uq-constr" table="loggers.deployment">
		<columns names="deployment_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="deployment_session_id_uq" type="uq-constr" table="loggers.deployment">
		<columns names="session_id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="logger_fate">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="80" y="1320"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="logger_fate" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="logger_fate_pk" type="pk-constr" table="metadata.logger_fate">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="fate_unique" type="uq-constr" table="metadata.logger_fate">
		<columns names="logger_fate" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•logger_fate⸣
•testfate⸣
•Calibration⸣
•Deployed⸣
•Double tagging⸣
•Lost⸣
•Lost before deployment⸣
•Redeployed⸣
•Sent to producer⸣
•Stored⸣
•Stored at location⸣
•Assigned to another project]]>
	</initial-data>
</table>

<schema name="individuals" rect-visible="true" fill-color="#ffff00">
	<role name="admin"/>
</schema>

<table name="individ_info">
	<schema name="individuals"/>
	<role name="admin"/>
	<position x="80" y="2003.76"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="individ_id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="ring_number">
		<type name="text" length="0"/>
	</column>
	<column name="euring_code">
		<type name="text" length="0"/>
	</column>
	<column name="species">
		<type name="text" length="0"/>
	</column>
	<column name="color_ring">
		<type name="text" length="0"/>
	</column>
	<column name="morph">
		<type name="text" length="0"/>
	</column>
	<column name="subspecies">
		<type name="text" length="0"/>
	</column>
	<column name="age">
		<type name="text" length="0"/>
	</column>
	<column name="sex">
		<type name="text" length="0"/>
	</column>
	<column name="sexing_method">
		<type name="text" length="0"/>
	</column>
	<column name="latest_info_date" not-null="true">
		<type name="date" length="0"/>
	</column>
	<constraint name="individ_info_pk" type="pk-constr" table="individuals.individ_info">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="individ_id_uq" type="uq-constr" table="individuals.individ_info">
		<columns names="individ_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="metalring_uq" type="uq-constr" table="individuals.individ_info">
		<columns names="ring_number,euring_code" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[metalring_id•species•morph•subspecies•age•sex•sexing_method•individ_id⸣
1•Common guillemot••••male•dna•1⸣
2•Brünnich's guillemot••••female•morphology•2⸣
3•Little auk••Alle alle alle••unknown•behaviour•3⸣
4•Little auk••Alle alle polaris••male•dna•4⸣
5•Atlantic puffin••••female•morphology•5⸣
6•Black-legged kittiwake••••unknown•behaviour•6⸣
7•Northern fulmar••••male•dna•7⸣
8•Lesser black-backed gull••Larus fuscus intermedius••female•morphology•8⸣
9•Lesser black-backed gull••Larus fuscus fuscus••unknown•behaviour•9⸣
10•Lesser black-backed gull••Larus fuscus graellsii••male•dna•10⸣
11•Herring gull••••female•morphology•11⸣
12•Glaucous gull••••unknown•behaviour•12⸣
13•European shag••••male•dna•13⸣
14•Common eider••••female•morphology•14]]>
	</initial-data>
</table>

<table name="sex">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="60" y="1460"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="sex" not-null="true">
		<type name="text" length="20"/>
	</column>
	<constraint name="sex_pk" type="pk-constr" table="metadata.sex">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="sex_unique" type="uq-constr" table="metadata.sex">
		<columns names="sex" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•sex⸣
•male⸣
•female⸣
•unknown]]>
	</initial-data>
</table>

<table name="sexing_method">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="400" y="1420"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="method">
		<type name="text" length="40"/>
	</column>
	<constraint name="sexing_method_pk" type="pk-constr" table="metadata.sexing_method">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="sexing_method_unique" type="uq-constr" table="metadata.sexing_method">
		<columns names="method" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•method⸣
•testmethod⸣
•dna⸣
•morphology⸣
•behaviour⸣
•none_yet]]>
	</initial-data>
</table>

<table name="individ_status">
	<schema name="individuals"/>
	<role name="admin"/>
	<position x="437.143" y="2062.22"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="logger_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="status_date">
		<type name="date" length="0"/>
	</column>
	<column name="status_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="session_id">
		<type name="integer" length="0"/>
	</column>
	<column name="weight">
		<type name="double precision" length="0"/>
	</column>
	<column name="scull">
		<type name="double precision" length="0"/>
	</column>
	<column name="tarsus">
		<type name="double precision" length="0"/>
	</column>
	<column name="wing">
		<type name="double precision" length="0"/>
	</column>
	<column name="breeding_stage">
		<type name="text" length="0"/>
	</column>
	<column name="eggs">
		<type name="smallint" length="0"/>
	</column>
	<column name="chicks">
		<type name="smallint" length="0"/>
	</column>
	<column name="hatching_success">
		<type name="boolean" length="0"/>
	</column>
	<column name="breeding_success">
		<type name="boolean" length="0"/>
	</column>
	<column name="breeding_success_criterion">
		<type name="text" length="20"/>
	</column>
	<column name="data_responsible" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="back_on_nest">
		<type name="boolean" length="0"/>
	</column>
	<column name="comment">
		<type name="text" length="0"/>
	</column>
	<column name="location">
		<type name="text" length="0"/>
	</column>
	<column name="ring_number" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="euring_code" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="species">
		<type name="text" length="0"/>
	</column>
	<column name="color_ring">
		<type name="text" length="0"/>
	</column>
	<column name="morph">
		<type name="text" length="0"/>
	</column>
	<column name="subspecies">
		<type name="text" length="0"/>
	</column>
	<column name="age">
		<type name="text" length="0"/>
	</column>
	<column name="sex">
		<type name="text" length="0"/>
	</column>
	<column name="sexing_method">
		<type name="text" length="0"/>
	</column>
	<constraint name="individ_status_pk" type="pk-constr" table="individuals.individ_status">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="status_id" type="uq-constr" table="individuals.individ_status">
		<columns names="status_id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="retrieval">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="1460" y="1741.11"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="retrieval_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="attribute_name">
		<type name="text" length="0"/>
	</column>
	<column name="logger_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="individ_id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="retrieval_type">
		<type name="text" length="0"/>
	</column>
	<column name="retrieval_location">
		<type name="text" length="0"/>
	</column>
	<column name="retrieval_date" not-null="true">
		<type name="date" length="0"/>
	</column>
	<constraint name="retrieval_pk" type="pk-constr" table="loggers.retrieval">
		<columns names="id,retrieval_date" ref-type="src-columns"/>
	</constraint>
	<constraint name="retrieval_id_unique" type="uq-constr" table="loggers.retrieval">
		<columns names="retrieval_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="retrieval_session_id_uq" type="uq-constr" table="loggers.retrieval">
		<columns names="session_id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="shutdown">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="1560" y="1240"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="download_type" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="download_date">
		<type name="date" length="0"/>
	</column>
	<column name="field_status">
		<type name="text" length="0"/>
	</column>
	<column name="downloaded_by">
		<type name="text" length="0"/>
	</column>
	<column name="decomissioned">
		<type name="boolean" length="0"/>
	</column>
	<column name="shutdown_date">
		<type name="date" length="0"/>
	</column>
	<constraint name="shutdown_pk" type="pk-constr" table="loggers.shutdown">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="shutdown_session_id_unique" type="uq-constr" table="loggers.shutdown">
		<columns names="session_id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="file_archive">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="1679.05" y="1560.95"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="file_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="filename">
		<type name="text" length="0"/>
	</column>
	<constraint name="file_archive_pk" type="pk-constr" table="loggers.file_archive">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<schema name="positions" rect-visible="true" fill-color="#ff5500">
	<role name="admin"/>
</schema>

<table name="postable">
	<schema name="positions"/>
	<role name="admin"/>
	<position x="2061.11" y="60"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="date_time" not-null="true">
		<type name="timestamp" length="0" precision="0"/>
	</column>
	<column name="logger" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="logger_id" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="logger_model" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="year_tracked" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="session_id">
		<type name="integer" length="0"/>
	</column>
	<column name="year_deployed" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="year_retrieved" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="ring_number">
		<type name="text" length="0"/>
	</column>
	<column name="euring_code">
		<type name="text" length="0"/>
	</column>
	<column name="species" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="colony" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="lon_raw">
		<type name="double precision" length="0"/>
	</column>
	<column name="lat_raw">
		<type name="double precision" length="0"/>
	</column>
	<column name="lon_smooth1">
		<type name="double precision" length="0"/>
	</column>
	<column name="lat_smooth1">
		<type name="double precision" length="0"/>
	</column>
	<column name="lon_smooth2">
		<type name="double precision" length="0"/>
	</column>
	<column name="lat_smooth2">
		<type name="double precision" length="0"/>
	</column>
	<column name="disttocol_s2">
		<type name="double precision" length="0"/>
	</column>
	<column name="eqfilter1">
		<type name="smallint" length="0"/>
	</column>
	<column name="eqfilter2">
		<type name="smallint" length="0"/>
	</column>
	<column name="eqfilter3">
		<type name="smallint" length="0"/>
	</column>
	<column name="lat_smooth2_eqfilt3">
		<type name="double precision" length="0"/>
	</column>
	<column name="sex">
		<type name="text" length="0"/>
	</column>
	<column name="morph">
		<type name="text" length="0"/>
	</column>
	<column name="subspecies">
		<type name="text" length="0"/>
	</column>
	<column name="age">
		<type name="text" length="0"/>
	</column>
	<column name="col_lon">
		<type name="double precision" length="0"/>
	</column>
	<column name="col_lat">
		<type name="double precision" length="0"/>
	</column>
	<column name="tfirst">
		<type name="timestamp" length="0" precision="0"/>
	</column>
	<column name="tsecond">
		<type name="timestamp" length="0" precision="0"/>
	</column>
	<column name="twl_type">
		<type name="smallint" length="0"/>
	</column>
	<column name="conf">
		<type name="smallint" length="0"/>
	</column>
	<column name="sun">
		<type name="double precision" length="0"/>
	</column>
	<column name="software">
		<type name="text" length="0"/>
	</column>
	<column name="light_threshold">
		<type name="smallint" length="0"/>
	</column>
	<column name="analyzer">
		<type name="text" length="0"/>
	</column>
	<column name="data_responsible">
		<type name="text" length="0"/>
	</column>
	<column name="logger_yeartracked">
		<type name="text" length="0"/>
	</column>
	<column name="posdata_file">
		<type name="text" length="0"/>
	</column>
	<column name="import_date">
		<type name="date" length="0"/>
	</column>
	<column name="data_version" default-value="1">
		<type name="integer" length="0"/>
	</column>
	<column name="database_version" default-value="2">
		<type name="integer" length="0"/>
	</column>
	<constraint name="postable_pk" type="pk-constr" table="positions.postable">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="processing">
	<schema name="positions"/>
	<role name="admin"/>
	<position x="2508.33" y="66.6667"/>
	<column name="id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="logger_yertracked" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="firstdate_light">
		<type name="date" length="0"/>
	</column>
	<column name="lastdate_light">
		<type name="date" length="0"/>
	</column>
	<column name="first_aut_eq">
		<type name="date" length="0"/>
	</column>
	<column name="last_aut_eq">
		<type name="date" length="0"/>
	</column>
	<column name="first_spring_eq">
		<type name="date" length="0"/>
	</column>
	<column name="last_spring_eq">
		<type name="date" length="0"/>
	</column>
	<column name="software">
		<type name="text" length="0"/>
	</column>
	<column name="light_threshold">
		<type name="double precision" length="0"/>
	</column>
	<column name="trn_file">
		<type name="text" length="0"/>
	</column>
	<column name="processing_file">
		<type name="text" length="0"/>
	</column>
	<column name="posdata_file">
		<type name="text" length="0"/>
	</column>
	<column name="logger_download_success">
		<type name="boolean" length="0"/>
	</column>
	<column name="logger_date_failed">
		<type name="boolean" length="0"/>
	</column>
	<column name="analyzer">
		<type name="text" length="0"/>
	</column>
	<column name="logger_id_retrieved">
		<type name="bigint" length="0"/>
	</column>
	<column name="year_tracked">
		<type name="smallint" length="0"/>
	</column>
	<column name="year_retrieved">
		<type name="smallint" length="0"/>
	</column>
	<column name="logger_model_retrieved">
		<type name="text" length="0"/>
	</column>
	<column name="logger_producer">
		<type name="text" length="0"/>
	</column>
	<column name="ring_number">
		<type name="text" length="0"/>
	</column>
	<column name="euring_code">
		<type name="text" length="0"/>
	</column>
	<column name="species">
		<type name="text" length="0"/>
	</column>
	<column name="sex">
		<type name="text" length="0"/>
	</column>
	<column name="morph">
		<type name="text" length="0"/>
	</column>
	<column name="subspecies">
		<type name="text" length="0"/>
	</column>
	<column name="age">
		<type name="smallint" length="0"/>
	</column>
	<column name="colony">
		<type name="text" length="0"/>
	</column>
	<constraint name="processing_pk" type="pk-constr" table="positions.processing">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="subspecies">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="478.59" y="503.077"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="species_name_eng" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="species_name_latin" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="sub_species">
		<type name="text" length="0"/>
	</column>
	<constraint name="subspecies_pk" type="pk-constr" table="metadata.subspecies">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="species_uq" type="uq-constr" table="metadata.subspecies">
		<columns names="sub_species,species_name_eng" ref-type="src-columns"/>
		<comment><![CDATA[Might not be necessarily unique?]]></comment>
	</constraint>
	<constraint name="species_latin_subspecies_uq" type="uq-constr" table="metadata.subspecies">
		<columns names="species_name_latin,sub_species" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[species_name_latin•sub_species•id•species_name_eng⸣
Uria aalge•••Common guillemot⸣
Uria lomvia•••Brünnich's guillemot⸣
Alle alle•Alle alle alle••Little auk⸣
Alle alle•Alle alle polaris••Little auk⸣
Fratercula arctica•••Atlantic puffin⸣
Rissa tridactyla•••Black-legged kittiwake⸣
Fulmarus glacialis•••Northern fulmar⸣
Larus fuscus•Larus fuscus intermedius••Lesser black-backed gull⸣
Larus fuscus•Larus fuscus fuscus••Lesser black-backed gull⸣
Larus fuscus•Larus fuscus graellsii••Lesser black-backed gull⸣
Larus argentatus•••Herring gull⸣
Larus hyperboreus•••Glaucous gull⸣
Phalacrocorax aristotelis•••European shag⸣
Somateria mollissima•••Common eider⸣
Testus specius•testus••testspecies⸣
Testus specius•specius••testspecies]]>
	</initial-data>
</table>

<table name="events">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="1560" y="881.818"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="logger_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="event_date" not-null="true">
		<type name="date" length="0"/>
	</column>
	<column name="status_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="deployment_id">
		<type name="integer" length="0"/>
	</column>
	<column name="retrieval_id">
		<type name="integer" length="0"/>
	</column>
	<column name="blood_sample">
		<type name="text" length="0"/>
	</column>
	<column name="feather_sample">
		<type name="text" length="0"/>
	</column>
	<column name="other_samples">
		<type name="text" length="0"/>
	</column>
	<constraint name="status_id" type="uq-constr" table="loggers.events">
		<columns names="status_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="events_pk" type="pk-constr" table="loggers.events">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="event_id_deployment_id_uq" type="uq-constr" table="loggers.events">
		<columns names="status_id,deployment_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="event_id_retrieval_uq" type="uq-constr" table="loggers.events">
		<columns names="status_id,retrieval_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="logger_date_uq" type="uq-constr" table="loggers.events">
		<columns names="logger_id,event_date" ref-type="src-columns"/>
	</constraint>
</table>

<table name="logger_year_tracked">
	<schema name="positions"/>
	<role name="admin"/>
	<position x="2473.58" y="960.513"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<column name="logger" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="logger_year_tracked" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="session_id_uq" type="uq-constr" table="positions.logger_year_tracked">
		<columns names="session_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="logger_year_tracked_pk" type="pk-constr" table="positions.logger_year_tracked">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<schema name="activity" rect-visible="true" fill-color="#00ffff">
	<role name="admin"/>
</schema>

<table name="temperature">
	<schema name="activity"/>
	<role name="admin"/>
	<position x="2086.67" y="1197.22"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<constraint name="temperature_pk" type="pk-constr" table="activity.temperature">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="salinity">
	<schema name="activity"/>
	<role name="admin"/>
	<position x="2453.34" y="1192.22"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="integer" length="0"/>
	</column>
	<constraint name="salinity_pk" type="pk-constr" table="activity.salinity">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<schema name="views" rect-visible="true" fill-color="#e1e1e1">
	<role name="admin"/>
</schema>

<view name="postable">
	<schema name="views"/>
	<role name="admin"/>
	<position x="2070.24" y="1385"/>
	<reference>
		<expression><![CDATA[SELECT p.* 
FROM positions.postable p]]></expression>
	</reference>
</view>

<view name="active_logging_sessions">
	<schema name="views"/>
	<role name="admin"/>
	<position x="2317.51" y="1381.36"/>
	<reference>
		<expression><![CDATA[SELECT *
FROM loggers.logging_session
WHERE active = TRUE]]></expression>
	</reference>
</view>

<table name="startup">
	<schema name="loggers"/>
	<role name="admin"/>
	<position x="980" y="340"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="session_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="logger_id" not-null="true">
		<type name="integer" length="80"/>
	</column>
	<column name="starttime_gmt">
		<type name="timestamp" length="0" precision="0"/>
	</column>
	<column name="logging_mode">
		<type name="varchar" length="15"/>
	</column>
	<column name="started_by">
		<type name="text" length="0"/>
	</column>
	<column name="started_where">
		<type name="text" length="0"/>
	</column>
	<column name="days_delayed">
		<type name="smallint" length="0"/>
	</column>
	<column name="programmed_gmt_time">
		<type name="timestamp" length="0"/>
	</column>
	<constraint name="startup_pk" type="pk-constr" table="loggers.startup">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="session_id_unique" type="uq-constr" table="loggers.startup">
		<columns names="session_id" ref-type="src-columns"/>
	</constraint>
</table>

<schema name="functions" rect-visible="true" fill-color="#e1e1e1">
	<role name="admin"/>
</schema>

<function name="fn_update_location_geom"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN	
-- as this is an after trigger, NEW contains all the information we need even for INSERT
	UPDATE metadata.location SET 
	geom = ST_SetSRID(ST_MakePoint(NEW.lon,NEW.lat), 4326)
	WHERE id=NEW.id;

	--RAISE NOTICE 'UPDATING geo data for %, [%,%]' , NEW.id, NEW.lat, NEW.lon;	
    RETURN NULL; -- result is ignored since this is an AFTER trigger
  END;

]]></definition>
</function>

<trigger name="tr_insert_location_geom" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="metadata.location">
		<function signature="functions.fn_update_location_geom()"/>
</trigger>

<trigger name="fn_update_location_geom" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="metadata.location">
		<function signature="functions.fn_update_location_geom()"/>
		<columns names="lat,lon"/>
</trigger>

<function name="fn_update_colony_geom"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN	
-- as this is an after trigger, NEW contains all the information we need even for INSERT
	UPDATE metadata.colony SET 
	geom = ST_SetSRID(ST_MakePoint(NEW.lon,NEW.lat), 4326)
	WHERE id=NEW.id;

	--RAISE NOTICE 'UPDATING geo data for %, [%,%]' , NEW.id, NEW.lat, NEW.lon;	
    RETURN NULL; -- result is ignored since this is an AFTER trigger
  END;]]></definition>
</function>

<schema name="imports" rect-visible="true" fill-color="#ff00ff">
	<role name="admin"/>
</schema>

<table name="logger_import">
	<schema name="imports"/>
	<role name="admin"/>
	<position x="2621.9" y="1597.82"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="import_time" not-null="true" default-value="NOW()::timestamp(0)">
		<type name="timestamp" length="0" precision="0"/>
	</column>
	<column name="logger_serial_no" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="logger_model" not-null="true">
		<type name="text" length="80"/>
	</column>
	<column name="producer">
		<type name="text" length="0"/>
	</column>
	<column name="production_year">
		<type name="smallint" length="0"/>
	</column>
	<column name="project">
		<type name="text" length="0"/>
	</column>
	<column name="starttime_gmt">
		<type name="timestamp" length="0" precision="0"/>
	</column>
	<column name="logging_mode">
		<type name="varchar" length="15"/>
	</column>
	<column name="started_by">
		<type name="text" length="0"/>
	</column>
	<column name="started_where">
		<type name="text" length="0"/>
	</column>
	<column name="days_delayed">
		<type name="smallint" length="0"/>
	</column>
	<column name="programmed_gmt_time">
		<type name="timestamp" length="0" precision="0"/>
	</column>
	<column name="intended_species">
		<type name="text" length="0"/>
	</column>
	<column name="intended_location">
		<type name="text" length="0"/>
	</column>
	<column name="intended_deployer">
		<type name="text" length="0"/>
	</column>
	<column name="shutdown_session">
		<type name="boolean" length="0"/>
	</column>
	<column name="field_status">
		<type name="text" length="0"/>
	</column>
	<column name="downloaded_by">
		<type name="text" length="0"/>
	</column>
	<column name="download_date">
		<type name="date" length="0"/>
	</column>
	<column name="download_type">
		<type name="text" length="0"/>
	</column>
	<column name="decomissioned">
		<type name="boolean" length="0"/>
	</column>
	<column name="comment">
		<type name="text" length="0"/>
	</column>
	<column name="shutdown_date">
		<type name="date" length="0"/>
	</column>
	<constraint name="logger_import_pk" type="pk-constr" table="imports.logger_import">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="import_types" hide-ext-attribs="true">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="480" y="1580"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="import_type" not-null="true">
		<type name="varchar" length="20"/>
	</column>
	<constraint name="import_types_pk" type="pk-constr" table="metadata.import_types">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="import_types_uq" type="uq-constr" table="metadata.import_types">
		<columns names="import_type" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•import_type⸣
•startup⸣
•allocation⸣
•deployment⸣
•retrieval⸣
•status]]>
	</initial-data>
</table>

<table name="mounting_types">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="60" y="1620"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="logger_mount_method" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="mounting_types_pk" type="pk-constr" table="metadata.mounting_types">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="mounting_types_uq" type="uq-constr" table="metadata.mounting_types">
		<columns names="logger_mount_method" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•logger_mount_method⸣
•testmethod⸣
•tarsus⸣
•tibia]]>
	</initial-data>
</table>

<table name="observations">
	<schema name="individuals"/>
	<role name="admin"/>
	<position x="60" y="2562.22"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="individ_id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="lat" not-null="true">
		<type name="double precision" length="0"/>
	</column>
	<column name="lon" not-null="true">
		<type name="double precision" length="0"/>
	</column>
	<column name="geom">
		<type name="geometry" length="0" spatial-type="POINT" variation="0" srid="4326"/>
	</column>
	<constraint name="observations_pk" type="pk-constr" table="individuals.observations">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="fn_update_observations_geom"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN	
-- as this is an after trigger, NEW contains all the information we need even for INSERT
	UPDATE individuals.observations SET 
	geom = ST_SetSRID(ST_MakePoint(NEW.lon,NEW.lat), 4326)
	WHERE id=NEW.id;

	--RAISE NOTICE 'UPDATING geo data for %, [%,%]' , NEW.id, NEW.lat, NEW.lon;	
    RETURN NULL; -- result is ignored since this is an AFTER trigger
  END;]]></definition>
</function>

<trigger name="tr_insert_observation_geom" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="individuals.observations">
		<function signature="functions.fn_update_observations_geom()"/>
</trigger>

<trigger name="fn_update_observation_geom" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="individuals.observations">
		<function signature="functions.fn_update_observations_geom()"/>
		<columns names="lat,lon"/>
</trigger>

<function name="fn_check_logging_session_not_open"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN

	IF  bool_and(logging_session.active = TRUE 
		AND date_part('year', ls.starttime_gmt) = date_part('year', NEW.starttime_gmt))
		FROM loggers.logging_session,loggers.startup ls
		WHERE logging_session.logger_id = NEW.logger_id
		AND ls.logger_id = NEW.logger_id
		THEN
		RAISE EXCEPTION 'Logger % already in open logging session started the same year. Close this open session before starting new one', NEW.logger_id;
	
	ELSIF  bool_or(logging_session.active = TRUE)
		FROM loggers.logging_session
		WHERE logging_session.logger_id = NEW.logger_id
		THEN
		RAISE WARNING 'Logger % already in open logging session, started another year.', NEW.logger_id;
	END IF;


RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_check_open_logging_session" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.startup">
		<function signature="functions.fn_check_logging_session_not_open()"/>
</trigger>

<function name="fn_start_new_logging_session"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
    INSERT INTO
       loggers.logging_session(session_id,logger_id)
        VALUES(new.session_id,new.logger_id);
           RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_insert_new_logging_session" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.startup">
		<function signature="functions.fn_start_new_logging_session()"/>
</trigger>

<function name="fn_check_open_session_on_deployment"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
		IF bool_and(logging_session.logger_id != NEW.logger_id) 
			FROM loggers.logging_session
			THEN
			RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding deployment data', NEW.logger_id;
		END IF;
		IF bool_and(logging_session.active = FALSE)
			FROM loggers.logging_session
			WHERE logging_session.logger_id = NEW.logger_id
		THEN
		RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding deployment data', NEW.logger_id;
	END IF;
	NEW.session_id := logging_session.session_id
	FROM loggers.logging_session, loggers.startup
	WHERE NEW.logger_id = logging_session.logger_id
	AND logging_session.active = TRUE
	AND logging_session.session_id = startup.session_id
	AND date_part('year', startup.starttime_gmt) = date_part('year', NEW.deployment_date);
RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_check_open_session_on_deployment" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.deployment">
		<function signature="functions.fn_check_open_session_on_deployment()"/>
</trigger>

<function name="fn_update_session_on_deployment"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	WITH col as (SELECT session_id, colony_int_name
		FROM loggers.deployment d, metadata.location l
		WHERE d.deployment_location = l.location_name
		AND d.session_id = NEW.session_id)
		UPDATE loggers.logging_session update SET
		deployment_id = NEW.deployment_id,
		colony = col.colony_int_name, 
		species = NEW.deployment_species,
		individ_id = NEW.individ_id
		FROM col
		WHERE update.session_id = NEW.session_id
		AND col.session_id = NEW.session_id;

	    IF NEW.deployment_location != a.intended_location
		FROM (SELECT a.intended_location 
		FROM loggers.allocation a
		WHERE a.session_id = NEW.session_id) a THEN
            RAISE WARNING '% deployment location does not match indended location in allocation table', NEW.deployment_location;
        END IF;
	RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_update_session_on_deployment" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.deployment">
		<function signature="functions.fn_update_session_on_deployment()"/>
</trigger>

<function name="fn_check_open_session_on_retrieval"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF  bool_and(logging_session.logger_id != NEW.logger_id)
		FROM loggers.logging_session
	THEN 
		RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding deployment data', NEW.logger_id;
	END IF;
   
	IF bool_and(logging_session.active = FALSE) 			
		FROM loggers.logging_session
		WHERE logging_session.logger_id = NEW.logger_id
	THEN
		RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding deployment data', NEW.logger_id;
	END IF;
   
	IF bool_and(logging_session.deployment_id IS NULL)
			FROM loggers.logging_session
			WHERE logging_session.logger_id = NEW.logger_id
	THEN
		RAISE EXCEPTION 'Logger % not deployed. Logger must be deployed before retrieved.', NEW.logger_id;
	END IF;
		
	NEW.session_id := logging_session.session_id
	FROM loggers.logging_session
	WHERE NEW.logger_id = logging_session.logger_id
	AND logging_session.active = TRUE
	AND logging_session.individ_id = NEW.individ_id;
RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_check_session_on_retrieval" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="loggers.retrieval">
		<function signature="functions.fn_check_open_session_on_retrieval()"/>
</trigger>

<function name="fn_update_session_on_retrieval"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
		WITH dep as (SELECT r.session_id, deployment_date, retrieval_date
		FROM loggers.retrieval r, loggers.deployment d
		WHERE r.session_id = d.session_id
		AND r.session_id = NEW.session_id)
		UPDATE loggers.logging_session update SET
		retrieval_id = NEW.retrieval_id,
		year_tracked = date_part('year', dep.deployment_date) || '_' || date_part('year', dep.retrieval_date)::integer % 100
		FROM dep
		WHERE update.session_id = NEW.session_id
		AND NEW.session_id = dep.session_id;
	RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_update_session_on_retrieval" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.retrieval">
		<function signature="functions.fn_update_session_on_retrieval()"/>
</trigger>

<function name="fn_distribute_from_logger_import_table"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN

IF NEW.logger_serial_no || NEW.logger_model NOT IN (SELECT logger_serial_no || logger_model FROM loggers.logger_info)
	 THEN
	INSERT INTO loggers.logger_info
					(logger_serial_no,
					producer, 
					logger_model,
					production_year,
					project)
	VALUES(NEW.logger_serial_no,
					NEW.producer,
					NEW.logger_model,
					NEW.production_year,
					NEW.project);
	END IF;
	IF NEW.starttime_gmt IS NOT NULL AND NEW.shutdown_session IS NOT True THEN
	INSERT INTO loggers.startup 
					(logger_id,  
					starttime_gmt, 
					logging_mode, 
					started_by, 
					started_where, 
					days_delayed, 
					programmed_gmt_time)
	SELECT logger_info.logger_id,  
		NEW.starttime_gmt, 
		NEW.logging_mode, 
		NEW.started_by, 
		NEW.started_where, 
		NEW.days_delayed, 
		NEW.programmed_gmt_time
	FROM loggers.logger_info 
	WHERE logger_info.logger_model = NEW.logger_model
	AND logger_info.logger_serial_no = NEW.logger_serial_no;
	END IF;
	IF NEW.intended_species IS NOT NULL THEN
	INSERT INTO loggers.allocation 
					(logger_id,
					intended_species,
					intended_location,
					intended_deployer,
					starttime_gmt)
	SELECT logger_info.logger_id,
		NEW.intended_species,
		NEW.intended_location,
		NEW.intended_deployer,
		NEW.starttime_gmt
		FROM loggers.logger_info 
	WHERE logger_info.logger_model = NEW.logger_model
	AND logger_info.logger_serial_no = NEW.logger_serial_no;
	END IF;
	IF NEW.shutdown_session IS True THEN
		
		IF NEW.logger_serial_no || NEW.logger_model IN (SELECT logger_serial_no || logger_model  FROM (SELECT ls.session_id, ls.logger_id, li.logger_serial_no, li.logger_model, ls.active
							FROM loggers.logging_session ls , loggers.logger_info li, loggers.startup
							WHERE li.logger_serial_no = NEW.logger_serial_no
							AND li.logger_model = NEW.logger_model
							AND li.logger_id = ls.logger_id
							AND active IS True
							AND ls.session_id = startup.session_id
							AND startup.starttime_gmt = NEW.starttime_gmt) foo) THEN
			INSERT INTO loggers.shutdown (session_id,
																download_type,
																download_date,
																field_status,
																downloaded_by,
																decomissioned,
																shutdown_date)
							SELECT ls.session_id,
								
										NEW.download_type,
										NEW.download_date,
										NEW.field_status,
										NEW.downloaded_by,
										NEW.decomissioned,
										NEW.shutdown_date
							FROM loggers.logger_info li, loggers.logging_session ls, loggers.startup
							WHERE li.logger_serial_no = NEW.logger_serial_no
							AND li.logger_model = NEW.logger_model
							AND li.logger_id = ls.logger_id
							AND ls.active IS True
							AND ls.session_id = startup.session_id
							AND startup.starttime_gmt = NEW.starttime_gmt;
		ELSE RAISE EXCEPTION 'Logger % of model % not in an open logging session started at %',  NEW.logger_serial_no, NEW.logger_model, NEW.starttime_gmt;
		END IF;
	END IF;
RETURN NEW;
END;]]></definition>
</function>

<function name="fn_check_open_session_on_allocation"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
		IF bool_and(logging_session.logger_id != NEW.logger_id) 
			FROM loggers.logging_session
			THEN
			RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding allocation data', NEW.logger_id;
		END IF;
		IF bool_and(logging_session.active = FALSE)
			FROM loggers.logging_session, loggers.startup
			WHERE logging_session.logger_id = NEW.logger_id
			AND logging_session.session_id = startup.session_id
			AND startup.starttime_gmt = NEW.starttime_gmt
		THEN
		RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding allocation data', NEW.logger_id;
	END IF;
	NEW.session_id := logging_session.session_id
	FROM loggers.logging_session, loggers.startup
	WHERE NEW.logger_id = logging_session.logger_id
	AND logging_session.active = TRUE
	AND logging_session.session_id = startup.session_id
	AND startup.starttime_gmt = NEW.starttime_gmt;
RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_check_open_session_on_allocation" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.allocation">
		<function signature="functions.fn_check_open_session_on_allocation()"/>
</trigger>

<function name="fn_check_open_session_on_status"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
		IF bool_and(logging_session.logger_id != NEW.logger_id) 
			FROM loggers.logging_session
			THEN
			RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding status data', NEW.logger_id;
		END IF;
		IF bool_and(logging_session.active = FALSE)
			FROM loggers.logging_session
			WHERE logging_session.logger_id = NEW.logger_id
		THEN
		RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding status data', NEW.logger_id;
	END IF;
	NEW.session_id := logging_session.session_id
	FROM loggers.logging_session, individuals.individ_info
	WHERE NEW.logger_id = logging_session.logger_id
	AND logging_session.active = TRUE
	AND individ_info.individ_id = logging_session.individ_id
	AND NEW.ring_number = individ_info.ring_number
	AND NEW.euring_code = individ_info.euring_code;
RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_check_open_session_on_status" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="individuals.individ_status">
		<function signature="functions.fn_check_open_session_on_status()"/>
</trigger>

<table name="breeding_stages">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="558.182" y="1730.91"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="breeding_stage" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="breeding_stage_uq" type="uq-constr" table="metadata.breeding_stages">
		<columns names="breeding_stage" ref-type="src-columns"/>
	</constraint>
	<constraint name="breeding_stages_pk" type="pk-constr" table="metadata.breeding_stages">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•breeding_stage⸣
•nonbreeding/failed_breeder⸣
•prebreeding⸣
•incubating⸣
•rearing chicks⸣
•breeding/stage_unknown⸣
•failed breeder⸣
•unknown]]>
	</initial-data>
</table>

<trigger name="tr_distribute_import" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="imports.logger_import">
		<function signature="functions.fn_distribute_from_logger_import_table()"/>
</trigger>

<function name="fn_delete_rows_from_import"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	DELETE FROM imports.logger_import 
	WHERE logger_import.id = NEW.id;
	RETURN NEW;
END;]]></definition>
</function>

<view name="closed_sessions_not_shutdown">
	<schema name="views"/>
	<role name="admin"/>
	<position x="2070.24" y="1445"/>
	<reference>
		<expression><![CDATA[SELECT l.session_id, l.logger_id, l.year_tracked
FROM loggers.logging_session l left join loggers.shutdown s
ON l.session_id = s.session_id
WHERE s.session_id IS NULL ]]></expression>
	</reference>
</view>

<table name="logger_files">
	<schema name="metadata"/>
	<role name="admin"/>
	<comment><![CDATA[Reference table that specifies what files are created by which logger model]]></comment>
	<position x="560" y="100"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="logger_model" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="file_basename" not-null="true">
		<type name="text" length="0"/>
		<comment><![CDATA[base of filetype to be used as appendix on filename]]></comment>
	</column>
	<column name="logger_producer" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="logger_files_pk" type="pk-constr" table="metadata.logger_files">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[logger_model•file_basename•logger_producer•id⸣
c250•.deg•Migrate Technology•⸣
c250•driftadj.deg•Migrate Technology•⸣
c250•.lux•Migrate Technology•⸣
c250•driftadj.lux•Migrate Technology•⸣
c250•.trn•Migrate Technology•⸣
c250•driftadj.trn•Migrate Technology•⸣
c250•.sst•Migrate Technology•⸣
mk3006•.tem•Biotrack•⸣
mk3006•.trn•Biotrack•⸣
mk3006•.txt•Biotrack•⸣
mk3006•.act•Biotrack•⸣
mk3006•.lig•Biotrack•⸣
c330•.deg•Migrate Technology•⸣
c330•driftadj.deg•Migrate Technology•⸣
c330•.lux•Migrate Technology•⸣
c330•driftadj.lux•Migrate Technology•⸣
c330•.trn•Migrate Technology•⸣
c330•driftadj.trn•Migrate Technology•⸣
c330•.sst•Migrate Technology•⸣
f100•.deg•Migrate Technology•⸣
f100•driftadj.deg•Migrate Technology•⸣
f100•.lux•Migrate Technology•⸣
f100•driftadj.lux•Migrate Technology•⸣
f100•.trn•Migrate Technology•⸣
f100•driftadj.trn•Migrate Technology•⸣
f100•.sst•Migrate Technology•⸣
c65•.deg•Migrate Technology•⸣
c65•driftadj.deg•Migrate Technology•⸣
c65•.lux•Migrate Technology•⸣
c65•driftadj.lux•Migrate Technology•⸣
c65•.trn•Migrate Technology•⸣
c65•driftadj.trn•Migrate Technology•⸣
c65•.sst•Migrate Technology•⸣
w65•.deg•Migrate Technology•⸣
w65•driftadj.deg•Migrate Technology•⸣
w65•.lux•Migrate Technology•⸣
w65•driftadj.lux•Migrate Technology•⸣
w65•.trn•Migrate Technology•⸣
w65•driftadj.trn•Migrate Technology•⸣
w65•.sst•Migrate Technology•⸣
mk18•.trn•BAS•⸣
mk18•.txt•BAS•⸣
mk18•.act•BAS•⸣
mk18•.lig•BAS•⸣
mk18•.trn•BAS•⸣
mk18•.txt•BAS•⸣
mk18•.act•BAS•⸣
mk18•.lig•BAS•⸣
mk14•.trn•BAS•⸣
mk14•.txt•BAS•⸣
mk14•.act•BAS•⸣
mk14•.lig•BAS•⸣
mk13•.trn•BAS•⸣
mk13•.txt•BAS•⸣
mk13•.act•BAS•⸣
mk13•.lig•BAS•⸣
mk15•.tem•BAS•⸣
mk15•.trn•BAS•⸣
mk15•.txt•BAS•⸣
mk15•.act•BAS•⸣
mk15•.lig•BAS•⸣
mk4•.trn•BAS•⸣
mk4•.txt•BAS•⸣
mk4•.act•BAS•⸣
mk4•.lig•BAS•⸣
mk3005•.tem•Biotrack•⸣
mk3005•.trn•Biotrack•⸣
mk3005•.txt•Biotrack•⸣
mk3005•.act•Biotrack•⸣
mk3005•.lig•Biotrack•⸣
mk4083•.trn•Biotrack•⸣
mk4083•.txt•Biotrack•⸣
mk4083•.act•Biotrack•⸣
mk4083•.lig•Biotrack•⸣
mk4093•.trn•Biotrack•⸣
mk4093•.txt•Biotrack•⸣
mk4093•.act•Biotrack•⸣
mk4093•.lig•Biotrack•⸣
mk9•.trn•BAS•⸣
mk9•.txt•BAS•⸣
mk9•.act•BAS•⸣
mk9•.lig•BAS•⸣
LAT•.bin•LOTEK•⸣
LAT•_o.bin•LOTEK•]]>
	</initial-data>
</table>

<function name="fn_create_filenames_on_shutdown"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF (TG_OP = 'INSERT' AND (NEW.download_type = 'Successfully downloaded' 
									OR NEW.download_type = 'Reconstructed')) THEN
		WITH foo as (SELECT s.session_id, s.logger_id, l.logger_serial_no, l.logger_model, f.file_basename, EXTRACT(YEAR from r.retrieval_date) year_retr
		FROM  loggers.logging_session s INNER JOIN loggers.logger_info l ON s.logger_id = l.logger_id
		INNER JOIN loggers.retrieval r ON r.session_id = s.session_id 
		INNER JOIN metadata.logger_files f ON l.logger_model = f.logger_model	)
		INSERT INTO loggers.file_archive (session_id, filename)
		SELECT foo.session_id, logger_serial_no || '_' || foo.year_retr || '_' || foo.logger_model || foo.file_basename
		FROM foo
		WHERE foo.session_id = NEW.session_id;
	ELSEIF (TG_OP = 'UPDATE' AND (NEW.download_type = 'Successfully downloaded'
									OR NEW.download_type = 'Reconstructed')) THEN
		WITH foo as (SELECT s.session_id, s.logger_id, l.logger_serial_no, l.logger_model, f.file_basename , EXTRACT(YEAR from r.retrieval_date) year_retr
		FROM  loggers.logging_session s INNER JOIN loggers.logger_info l ON s.logger_id = l.logger_id
		INNER JOIN loggers.retrieval r ON r.session_id = s.session_id 
		INNER JOIN metadata.logger_files f ON l.logger_model = f.logger_model	)
		UPDATE loggers.file_archive SET
		session_id = foo.session_id,
		filename = foo.logger_serial_no || '_' || foo.year_retr || '_' || foo.logger_model || foo.file_basename
		FROM foo
		WHERE NEW.session_id = file_archive.session_id;
	END IF;
RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_create_filenames_on_shutdown" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.shutdown">
		<function signature="functions.fn_create_filenames_on_shutdown()"/>
</trigger>

<index name="logging_session_session_id_idx" table="loggers.logging_session"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="session_id"/>
		</idxelement>
</index>

<index name="logging_session_logger_id_idx" table="loggers.logging_session"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="logger_id"/>
		</idxelement>
</index>

<index name="ls_active_idx" table="loggers.logging_session"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="active"/>
		</idxelement>
</index>

<index name="ls_colony_idx" table="loggers.logging_session"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="colony"/>
		</idxelement>
</index>

<index name="ls_species_idx" table="loggers.logging_session"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="species"/>
		</idxelement>
</index>

<index name="ls_year_tracked_idx" table="loggers.logging_session"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="year_tracked"/>
		</idxelement>
</index>

<index name="ls_individ_idx" table="loggers.logging_session"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="individ_id"/>
		</idxelement>
</index>

<table name="retrieval_type">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="540" y="1260"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="retrieval_type_pk" type="pk-constr" table="metadata.retrieval_type">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="retrieval_type_uq" type="uq-constr" table="metadata.retrieval_type">
		<columns names="type" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•type⸣
•testtype⸣
•individual caught (logger retrieved, bird released without logger)⸣
•individual observed (logger still attached)⸣
•individual caught (first deployment)⸣
•individual caught (logger retrieved and replaced)⸣
•individual caught (logger lost and replaced)⸣
•individual observed (logger lost)⸣
•individual observed (logger status unknown)⸣
•individual found dead (logger still attached)⸣
•logger not used]]>
	</initial-data>
</table>

<table name="download_types">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="600" y="1000"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="download_type" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="download_types_pk" type="pk-constr" table="metadata.download_types">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="download_type_uq" type="uq-constr" table="metadata.download_types">
		<columns names="download_type" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•download_type⸣
•Error⸣
•Failed⸣
•Lost⸣
•Nonresponsive⸣
•Reconstructed⸣
•Successfully downloaded⸣
•Unknown⸣
•Unsuccessful reconstruction⸣
•Sleep mode]]>
	</initial-data>
</table>

<trigger name="tr_delete_after_import" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="imports.logger_import">
		<function signature="functions.fn_delete_rows_from_import()"/>
</trigger>

<table name="breeding_success_criterion">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="60" y="1780"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="breeding_success_criterion" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="breeding_success_criterion_pk" type="pk-constr" table="metadata.breeding_success_criterion">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="breeding_success_criterion_uq" type="uq-constr" table="metadata.breeding_success_criterion">
		<columns names="breeding_success_criterion" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•breeding_success_criterion⸣
•10d⸣
•15d⸣
•20d⸣
•25d⸣
•30d⸣
•fledging⸣
•none⸣
•unknown]]>
	</initial-data>
</table>

<function name="reject_process_colony_not_matching_any_type_name"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF NEW.colony NOT IN (SELECT DISTINCT x 
FROM metadata.location CROSS JOIN LATERAL
	(values(colony_int_name), (colony_nat_name)) as t(x)
WHERE x IS NOT NULL) THEN
RAISE EXCEPTION 'Colony name not present as native or international name in metadatal.locations table', NEW.colony;
END IF;
RETURN NEW;
END;
]]></definition>
</function>

<trigger name="tr_before_insert_or_update_process_check_colony_name" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="positions.processing">
		<function signature="functions.reject_process_colony_not_matching_any_type_name()"/>
		<columns names="colony"/>
</trigger>

<function name="fn_update_individ_info_logging_session"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN	
	UPDATE individuals.individ_status 
	SET session_id= foo.session_id
	FROM (SELECT s.session_id
				FROM loggers.logging_session s
				WHERE s.logger_id = NEW.logger_id
				AND s.active IS True) foo
	
	WHERE id=NEW.id;
    RETURN NULL; -- result is ignored since this is an AFTER trigger
  END;
]]></definition>
</function>

<trigger name="tr_update_individ_info_logging_session_on_insert_or_update" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="individuals.individ_status">
		<function signature="functions.fn_update_individ_info_logging_session()"/>
		<columns names="logger_id"/>
</trigger>

<table name="metadata_import">
	<schema name="imports"/>
	<role name="admin"/>
	<position x="2063.92" y="1583.99"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="date">
		<type name="date" length="0"/>
	</column>
	<column name="ring_number" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="euring_code" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="color_ring">
		<type name="text" length="0"/>
	</column>
	<column name="logger_status">
		<type name="text" length="0"/>
	</column>
	<column name="logger_model_retrieved">
		<type name="text" length="0"/>
	</column>
	<column name="logger_id_retrieved">
		<type name="text" length="0"/>
	</column>
	<column name="logger_model_deployed">
		<type name="text" length="0"/>
	</column>
	<column name="logger_id_deployed">
		<type name="text" length="0"/>
	</column>
	<column name="species">
		<type name="text" length="0"/>
	</column>
	<column name="morph">
		<type name="text" length="0"/>
	</column>
	<column name="subspecies">
		<type name="text" length="0"/>
	</column>
	<column name="age">
		<type name="text" length="0"/>
	</column>
	<column name="sex">
		<type name="text" length="0"/>
	</column>
	<column name="sexing_method">
		<type name="text" length="0"/>
	</column>
	<column name="weight">
		<type name="double precision" length="0"/>
	</column>
	<column name="scull">
		<type name="double precision" length="0"/>
	</column>
	<column name="tarsus">
		<type name="double precision" length="0"/>
	</column>
	<column name="wing">
		<type name="double precision" length="0"/>
	</column>
	<column name="breeding_stage">
		<type name="text" length="0"/>
	</column>
	<column name="eggs">
		<type name="smallint" length="0"/>
	</column>
	<column name="chicks">
		<type name="smallint" length="0"/>
	</column>
	<column name="hatching_success">
		<type name="boolean" length="0"/>
	</column>
	<column name="breeding_success">
		<type name="boolean" length="0"/>
	</column>
	<column name="breeding_success_criterion">
		<type name="text" length="0"/>
	</column>
	<column name="country">
		<type name="text" length="0"/>
	</column>
	<column name="colony">
		<type name="text" length="0"/>
	</column>
	<column name="colony_latitude">
		<type name="double precision" length="0"/>
	</column>
	<column name="colony_longitude">
		<type name="double precision" length="0"/>
	</column>
	<column name="nest_id">
		<type name="text" length="0"/>
	</column>
	<column name="blood_sample">
		<type name="text" length="0"/>
	</column>
	<column name="feather_sample">
		<type name="text" length="0"/>
	</column>
	<column name="other_samples">
		<type name="text" length="0"/>
	</column>
	<column name="data_responsible" not-null="true">
		<type name="text" length="0"/>
	</column>
	<column name="back_on_nest">
		<type name="boolean" length="0"/>
	</column>
	<column name="logger_mount_method">
		<type name="text" length="0"/>
	</column>
	<column name="comment">
		<type name="text" length="0"/>
	</column>
	<column name="other">
		<type name="text" length="0"/>
	</column>
	<column name="old_ring_number">
		<type name="text" length="0"/>
	</column>
	<column name="last_updated">
		<type name="timestamp" length="0"/>
	</column>
	<column name="updated_by">
		<type name="text" length="0"/>
	</column>
</table>

<table name="euring_codes">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="574.871" y="1135.64"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="euring_code" not-null="true">
		<type name="text" length="0"/>
	</column>
	<constraint name="euring_codes_pk" type="pk-constr" table="metadata.euring_codes">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[id•euring_code⸣
•NOS⸣
•NOO⸣
•RUM⸣
•GBT⸣
•ISR⸣
•DKC]]>
	</initial-data>
</table>

<textbox name="Issues" color="#ffaa00" font-size="9">
	<position x="948.167" y="2287.64"/>
	<comment><![CDATA[*  Metadata_import and logger_import needs to be split up.
    - Intended location (where does that come from? same as colony?)
    - Remove comment?
* Make a separate observation import table?

* Check the flowchart of importing the metadata
    1. Separately register new individuals (to be able to quality check ring numbers in metadata)
    2. Check that ring number corresponds to correct species
    3. Update all relevant tables with data from metadata tables (write triggers)

* Add lookup tables? 
    - standard values for blood and feather samples?
    - Morphs
    - logger_status
* Check age column of metadata_import. Metadata seems to contain lots of text in this column

* logger_import should have logger serial + logger model instead of logger id

pg_dump -C  -d gisdata -t seatrack.postable --data-only | psql -h ninseatrack01.nina.no -d seatrack -U jens.astrom

Another time I used 1. create seatrack.postable from def in gisdata, pg_dump -a that table. In pgadmin3 use restore to populate the table. Then insert into positions.postable from that. Works, but ugly.]]></comment>
</textbox>

<function name="fn_distribute_from_metadata_table"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
IF NEW.ring_number || NEW.euring_code NOT IN (SELECT ring_number || euring_code FROM individuals.individ_info) THEN
INSERT INTO individuals.individ_info (ring_number,
															euring_code,
															species,
															color_ring,
															morph,
															subspecies,
															age,
															sex,
															sexing_method,
															latest_info_date)		
					VALUES(NEW.ring_number,
									NEW.euring_code,
									NEW.species,
									NEW.color_ring,
									NEW.morph,
									NEW.subspecies,
									NEW.age,
									NEW.sex,
									NEW.sexing_method,
									NEW."date");
END IF;
	IF NEW.logger_model_deployed IS NOT NULL THEN
	INSERT INTO loggers.deployment
				(logger_id,
				individ_id,
				deployment_species,
				deployment_location,
				deployment_date,
				logger_mount_method)
	SELECT logging_session.logger_id,
				individ_info.individ_id,
				NEW.species,
				NEW.colony,
				NEW.date,
				NEW.logger_mount_method
FROM loggers.logging_session, loggers.logger_info, individuals.individ_info, loggers.startup
WHERE logging_session.logger_id = logger_info.logger_id
AND logger_info.logger_model = NEW.logger_model_deployed
AND logger_info.logger_serial_no = NEW.logger_id_deployed
AND logging_session.active IS True
AND individ_info.ring_number = NEW.ring_number
AND individ_info.euring_code = NEW.euring_code
AND logging_session.session_id =  startup.session_id
AND date_part('year', NEW.date) = date_part('year', startup.starttime_gmt);
	END IF;
IF NEW.date IN (SELECT individ_status.status_date
						FROM loggers.logging_session, individuals.individ_info, individuals.individ_status 
						WHERE individ_info.ring_number = NEW.ring_number
						AND individ_info.euring_code = NEW.euring_code
						AND individ_info.individ_id = logging_session.individ_id
						AND logging_session.active Is True
						AND logging_session.session_id = individ_status.session_id) 
THEN
	UPDATE individuals.individ_status
	SET 			weight = NEW.weight,
					scull = NEW.scull,
					tarsus = NEW.tarsus,
					wing = NEW.wing, 
					breeding_stage = NEW.breeding_stage,
					eggs = NEW.eggs,
					chicks = NEW.chicks, 
					hatching_success = NEW.hatching_success,
					breeding_success = NEW.breeding_success,
					breeding_success_criterion = NEW.breeding_success_criterion,
					data_responsible = NEW.data_responsible,
					back_on_nest = NEW.back_on_nest,
					"comment" = NEW."comment",
					"location" = NEW.colony,
						ring_number = NEW.ring_number,
						euring_code = NEW.euring_code,
						species = NEW.species, 
						color_ring = NEW.color_ring,
						morph = NEW.morph,
						subspecies = NEW.subspecies,
						age = NEW.age,
						sex = NEW.sex,
						sexing_method = NEW.sexing_method
		FROM loggers.logging_session, individuals.individ_info
		WHERE individ_status.logger_id = logging_session.logger_id
		AND status_date = NEW.date
		AND  individ_status.session_id = logging_session.session_id
		AND individ_info.ring_number = NEW.ring_number
		AND individ_info.euring_code = NEW.euring_code
		AND individ_info.individ_id = logging_session.individ_id
		AND logging_session.active Is True;
	
ELSE
	INSERT INTO individuals.individ_status	(logger_id,
					"status_date",
					session_id,
					weight,
					scull,
					tarsus,
					wing,
					breeding_stage,
					eggs,
					chicks,
					hatching_success,
					breeding_success,
					breeding_success_criterion,
					data_responsible,
					back_on_nest,
					"comment",
					"location",
						ring_number,
						euring_code,
						species,
						color_ring,
						morph,
						subspecies,
						age,
						sex,
						sexing_method)
	SELECT logging_session.logger_id,
					NEW.date,
					logging_session.session_id,
					NEW.weight,
					NEW.scull,
					NEW.tarsus,
					NEW.wing,
					NEW.breeding_stage,
					NEW.eggs,
					NEW.chicks,
					NEW.hatching_success,
					NEW.breeding_success,
					NEW.breeding_success_criterion,
					NEW.data_responsible,
					NEW.back_on_nest,
					NEW."comment",
					NEW.colony,
						NEW.ring_number,
						NEW.euring_code,
						NEW.species,
						NEW.color_ring,
						NEW.morph,
						NEW.subspecies,
						NEW.age,
						NEW.sex,
						NEW.sexing_method
				FROM loggers.logging_session, individuals.individ_info
				WHERE individ_info.ring_number = NEW.ring_number
				AND individ_info.euring_code = NEW.euring_code
				AND individ_info.individ_id = logging_session.individ_id
				AND logging_session.active Is True;
END IF;
	
	
IF NEW.logger_model_retrieved IS NOT NULL THEN
		INSERT INTO loggers.retrieval
					(logger_id,
					individ_id,
					retrieval_type,
					retrieval_location,
					retrieval_date)
		SELECT logging_session.logger_id,
					individ_info.individ_id,
					NEW.logger_status,
					NEW.colony,
					NEW.date
FROM loggers.logging_session, loggers.logger_info, individuals.individ_info
WHERE logging_session.logger_id = logger_info.logger_id
AND logger_info.logger_model = NEW.logger_model_retrieved
AND logger_info.logger_serial_no = NEW.logger_id_retrieved
AND logging_session.active IS True
AND individ_info.ring_number = NEW.ring_number
AND individ_info.euring_code = NEW.euring_code
AND logging_session.individ_id =  individ_info.individ_id;
END IF;
NEW.updated_by := current_user;
NEW.last_updated := now();
RETURN NEW;
END;]]></definition>
</function>

<function name="fn_deleted_uuid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
    INSERT INTO
        positions.deleted_uuid(id, import_date, deleted_date, posdata_file, user_name)
        VALUES(old.id,old.import_date, CURRENT_DATE, old.posdata_file, user);

           RETURN OLD;
END;
]]></definition>
</function>

<function name="fn_update_data_version"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
  NEW.data_version := OLD.data_version + 1;
  RETURN NEW;
END; 
]]></definition>
</function>

<function name="fn_update_import_date"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
  NEW.import_date := CURRENT_DATE;
  RETURN NEW;
END; 
]]></definition>
</function>

<function name="fn_used_uuid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
    INSERT INTO
        positions.used_uuid(id, import_date,posdata_file, user_name)
        VALUES(new.id,new.import_date, new.posdata_file, user);
           RETURN new;
END;
]]></definition>
</function>

<table name="deleted_uuid">
	<schema name="positions"/>
	<role name="admin"/>
	<position x="2758.34" y="735"/>
	<column name="id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="import_date">
		<type name="date" length="0"/>
	</column>
	<column name="deleted_date">
		<type name="date" length="0"/>
	</column>
	<column name="posdata_file">
		<type name="text" length="0"/>
	</column>
	<column name="user_name">
		<type name="text" length="0"/>
	</column>
	<constraint name="deleted_uuid_pk" type="pk-constr" table="positions.deleted_uuid">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="used_uuid">
	<schema name="positions"/>
	<role name="admin"/>
	<position x="2461.67" y="741.667"/>
	<column name="id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="import_date">
		<type name="date" length="0"/>
	</column>
	<column name="posdata_file">
		<type name="text" length="0"/>
	</column>
	<column name="user_name">
		<type name="text" length="0"/>
	</column>
	<constraint name="used_uuid_pk" type="pk-constr" table="positions.used_uuid">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<trigger name="tr_deleted_uuid_trigger" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="positions.postable">
		<function signature="functions.fn_deleted_uuid()"/>
</trigger>

<trigger name="tr_update_data_version" firing-type="AFTER" per-line="true" constraint="true"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="positions.postable">
	<condition><![CDATA[pg_trigger_depth() = 0]]></condition>
		<function signature="functions.fn_update_data_version()"/>
</trigger>

<trigger name="tr_update_import_date" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="positions.postable">
		<function signature="functions.fn_update_import_date()"/>
</trigger>

<trigger name="tr_used_uuid" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="positions.postable">
		<function signature="functions.fn_used_uuid()"/>
</trigger>

<trigger name="tr_distribute_on_metadata_import" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="imports.metadata_import">
		<function signature="functions.fn_distribute_from_metadata_table()"/>
</trigger>

<index name="postable_datarespons_idx" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="data_responsible"/>
		</idxelement>
</index>

<index name="postable_datetime_idx" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="date_time"/>
		</idxelement>
</index>

<index name="postable_eqfilter3_idx" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="eqfilter3"/>
		</idxelement>
</index>

<index name="postable_id_idx" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="id"/>
		</idxelement>
</index>

<index name="postable_postdatafile_idx" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="posdata_file"/>
		</idxelement>
</index>

<index name="postable_species_idx" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="species"/>
		</idxelement>
</index>

<index name="postable_ring_idx" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="ring_number"/>
		</idxelement>
</index>

<index name="postable_logger_idx" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="logger_id"/>
		</idxelement>
</index>

<function name="fn_check_open_session_on_metadata_deployment"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
		IF COALESCE(bool_and(logging_session.logger_id != logger_info.logger_id), False) 
			FROM loggers.logging_session, loggers.logger_info
			WHERE logger_info.logger_model = NEW.logger_model_deployed
			AND logger_info.logger_serial_no = NEW.logger_id_deployed
		THEN
			RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding deployment data.', NEW.logger_id_deployed;
		END IF;
		IF COALESCE(bool_and(logging_session.active IS NOT True), False)
			FROM loggers.logging_session, loggers.logger_info
			WHERE logging_session.logger_id = logger_info.logger_id
			AND logger_info.logger_model = NEW.logger_model_deployed
			AND logger_info.logger_serial_no = NEW.logger_id_deployed
		THEN
		RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding deployment data.', NEW.logger_id_deployed;
	END IF;

		IF COALESCE(NOT bool_or(date_part('year', startup.starttime_gmt) = date_part('year', NEW.date)), False)
			FROM loggers.logging_session, loggers.logger_info, loggers.startup
			WHERE logging_session.logger_id = logger_info.logger_id
			AND logging_session.session_id = startup.session_id
			AND logger_info.logger_model = NEW.logger_model_deployed
			AND logger_info.logger_serial_no = NEW.logger_id_deployed
		THEN RAISE EXCEPTION 'Logger % not started up in the year it was deployed. Make sure startup year matches the deployement year.', NEW.logger_id_deployed;
	END IF;
RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_check_open_session_on_metadata_deployment" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="imports.metadata_import">
		<function signature="functions.fn_check_open_session_on_metadata_deployment()"/>
</trigger>

<function name="fn_check_open_session_on_metadata_retrieval"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF  bool_and(logging_session.logger_id != logger_info.logger_id)
			FROM loggers.logging_session, loggers.logger_info, individuals.individ_info
			WHERE logger_info.logger_model = NEW.logger_model_retrieved
			AND logger_info.logger_serial_no = NEW.logger_id_retrieved
	THEN 
		RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding deployment data', NEW.logger_id_retrieved;
	END IF;
   
	IF bool_and(logging_session.active IS NOT True)		
			FROM loggers.logging_session, loggers.logger_info, individuals.individ_info
			WHERE logging_session.logger_id = logger_info.logger_id
			AND logger_info.logger_model = NEW.logger_model_retrieved
			AND logger_info.logger_serial_no = NEW.logger_id_retrieved
	THEN
		RAISE EXCEPTION 'Logger % not in open logging session. Open session before adding deployment data', NEW.logger_id_retrieved;
	END IF;
   
	IF bool_and(logging_session.deployment_id IS NULL)
			FROM loggers.logging_session, loggers.logger_info, individuals.individ_info
			WHERE logging_session.logger_id = logger_info.logger_id
			AND logger_info.logger_model = NEW.logger_model_retrieved
			AND logger_info.logger_serial_no = NEW.logger_id_retrieved
	THEN
		RAISE EXCEPTION 'Logger % not deployed. Logger must be deployed before retrieved.', NEW.logger_id_retrieved;
	END IF;
RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_check_open_session_on_metadata_retrieval" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="imports.metadata_import">
		<function signature="functions.fn_check_open_session_on_metadata_retrieval()"/>
</trigger>

<view name="categories" materialized="true">
	<schema name="views"/>
	<role name="admin"/>
	<position x="2313.8" y="1479.76"/>
	<reference>
		<expression><![CDATA[ species as species_cat, colony as colony_cat, data_responsible as responsible_cat
    , ring_number as ring_number_cat
    FROM positions.postable
    GROUP BY species, colony, data_responsible, ring_number]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
</view>

<view name="longersum" materialized="true">
	<schema name="views"/>
	<role name="admin"/>
	<position x="2598.57" y="1368.33"/>
	<reference>
		<expression><![CDATA[year_tracked år, species, count(distinct(ring_number)) antall_unike_ring_nummer, count(*) antall_posisjoner, count(distinct(colony)) antall_kolonier
    FROM positions.postable
    GROUP BY år, species
    ORDER BY år, species]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
</view>

<view name="shorttable" materialized="true">
	<schema name="views"/>
	<role name="admin"/>
	<position x="2600.24" y="1461.67"/>
	<reference>
		<expression><![CDATA[ count(DISTINCT postable.species) AS "Antall arter",
    count(DISTINCT postable.colony) AS "Antall kolonier",
    count(DISTINCT postable.year_tracked) AS "Antall år",
    count(*) AS "Antall positions",
    count(DISTINCT postable.ring_number) AS "Antall individer"
   FROM positions.postable]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
</view>

<view name="shorttableeqfilter3">
	<schema name="views"/>
	<role name="admin"/>
	<position x="2600.24" y="1440"/>
	<reference>
		<expression><![CDATA[count(DISTINCT postable.species) AS "Antall arter",
    count(DISTINCT postable.colony) AS "Antall kolonier",
    count(DISTINCT postable.year_tracked) AS "Antall år",
    count(*) AS "Antall positions",
    count(DISTINCT postable.ring_number) AS "Antall individer"
   FROM positions.postable
  WHERE postable.eqfilter3 = 1]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
</view>

<function name="fn_update_materialized_views_on_postable_update"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
REFRESH MATERIALIZED VIEW views.categories;
REFRESH MATERIALIZED VIEW views.longersum;
REFRESH MATERIALIZED VIEW views.shorttable;
RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_update_matviews_on_postable_update" firing-type="AFTER" per-line="true" constraint="true"
	 ins-event="true" del-event="true" upd-event="true" trunc-event="false"
	 table="positions.postable">
	<condition><![CDATA[pg_trigger_depth() = 0]]></condition>
		<function signature="functions.fn_update_materialized_views_on_postable_update()"/>
</trigger>

<view name="all_depl_mismatch">
	<schema name="views"/>
	<role name="postgres"/>
	<position x="2320.66" y="1429.96"/>
	<reference>
		<expression><![CDATA[
a.session_id, a.logger_id, a.intended_species, a.intended_location, a.intended_deployer , d.deployment_species, d.deployment_location, d.deployment_date
FROM loggers.allocation a join loggers.deployment d on
a.session_id = d.session_id
WHERE intended_location != deployment_location
]]></expression>
	</reference>
	<expression type="select-exp">0</expression>
</view>

<function name="fn_update_individ_info_from_individ_status"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	
	IF NEW.ring_number || NEW.euring_code IN (SELECT ring_number || euring_code FROM individuals.individ_info) THEN
		IF NEW.species != (SELECT(foo.species)
		FROM (SELECT species, ring_number, euring_code FROM individuals.individ_info) foo
		WHERE NEW.ring_number = foo.ring_number
		AND NEW.euring_code = foo.euring_code) THEN
		RAISE EXCEPTION 'Species id for metalring number % does not match old species', NEW.ring_number;
		END IF;

		UPDATE individuals.individ_info
		SET latest_info_date = NEW.status_date
		WHERE ring_number = NEW.ring_number
		AND euring_code = NEW.euring_code; 
		IF NEW.color_ring IS NOT NULL THEN
			UPDATE individuals.individ_info
				SET color_ring = NEW.color_ring
				WHERE ring_number = NEW.ring_number
				AND euring_code = NEW.euring_code;
		END IF;
		IF NEW.morph IS NOT NULL THEN
			UPDATE individuals.individ_info
				SET morph = NEW.morph
				WHERE ring_number = NEW.ring_number
				AND euring_code = NEW.euring_code;
		END IF;
		IF NEW.subspecies IS NOT NULL THEN
			UPDATE individuals.individ_info
				SET subspecies = NEW.subspecies
				WHERE ring_number = NEW.ring_number
				AND euring_code = NEW.euring_code;
		END IF;
		IF NEW.age IS NOT NULL THEN
			UPDATE individuals.individ_info
				SET age = NEW.age
				WHERE ring_number = NEW.ring_number
				AND euring_code = NEW.euring_code;
		END IF;
		IF NEW.sex IS NOT NULL THEN
			UPDATE individuals.individ_info
				SET sex = NEW.sex,
				sexing_method = NEW.sexing_method
				WHERE ring_number = NEW.ring_number
				AND euring_code = NEW.euring_code;
		END IF;
	END IF;
RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_update_individ_info_from_individ_status" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="individuals.individ_status">
		<function signature="functions.fn_update_individ_info_from_individ_status()"/>
</trigger>

<function name="fn_check_retrieval_match_with_deployment"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF NEW.individ_id != d.individ_id 
	FROM loggers.deployment d
	WHERE NEW.session_id = d.session_id THEN
	RAISE EXCEPTION 'Retrieved individual % does not match deployed individual ', NEW.individ_id;
	END IF;
RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_check_mismatch_with_deployment" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.retrieval">
		<function signature="functions.fn_check_retrieval_match_with_deployment()"/>
</trigger>

<function name="fn_update_session_on_shutdown"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	UPDATE loggers.logging_session
	SET active = 'False'
	WHERE session_id = NEW.session_id;
	RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_update_session_on_shutdown" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="loggers.shutdown">
		<function signature="functions.fn_update_session_on_shutdown()"/>
</trigger>

<function name="fn_check_shutdown_after_startup"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF NEW.download_date < (SELECT starttime_gmt::date
				FROM loggers.startup
				WHERE NEW.session_id = startup.session_id) THEN

				SELECT raise_logger_session_exception(logger_serial_no, session_id)
				FROM (SELECT starttime_gmt::date, logger_info.logger_serial_no, logging_session.session_id 
				FROM loggers.startup, loggers.logger_info, loggers.logging_session
				WHERE NEW.session_id = logging_session.session_id
				AND logging_session.logger_id = logger_info.logger_id) fo;

	
	END IF;
	RETURN NULL;
END;]]></definition>
</function>

<function name="fn_check_retr_after_depl"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF NEW.retrieval_date < (SELECT deployment_date
				FROM loggers.deployment
				WHERE NEW.session_id = deployment.session_id) THEN 

				SELECT functions.fn_raise_download_date_exception(logger_serial_no, session_id)
				FROM (SELECT logger_info.logger_serial_no, logging_session.session_id 
				FROM loggers.logger_info, loggers.logging_session
				WHERE NEW.session_id = logging_session.session_id
				AND logging_session.logger_id = logger_info.logger_id) fo;
	
	END IF;
	RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_check_retr_after_depl" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.retrieval">
		<function signature="functions.fn_check_retr_after_depl()"/>
</trigger>

<function name="fn_check_depl_after_startup"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF (
	(NEW.deployment_date < (SELECT programmed_gmt_time::date
				FROM loggers.startup
				WHERE NEW.session_id = startup.session_id)) 
				OR
				
	(NEW.deployment_date < (SELECT starttime_gmt::date
				FROM loggers.startup
				WHERE NEW.session_id = startup.session_id) 
				AND
				
				(SELECT programmed_gmt_time::date
				FROM loggers.startup
				WHERE NEW.session_id = startup.session_id) IS NULL)
				) 
				THEN
				
				SELECT functions.fn_raise_deployment_date_exception(logger_serial_no, session_id)
				FROM (SELECT logger_info.logger_serial_no, logging_session.session_id 
				FROM loggers.startup, loggers.logger_info, loggers.logging_session
				WHERE NEW.session_id = logging_session.session_id
				AND logging_session.logger_id = logger_info.logger_id) fo;
	
	END IF;
	RETURN NULL;
END;]]></definition>
</function>

<trigger name="tr_check_depl_after_startup" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.deployment">
		<function signature="functions.fn_check_depl_after_startup()"/>
</trigger>

<function name="fn_raise_download_date_exception"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="logger_id">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="session_id">
		<type name="integer" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
  RAISE EXCEPTION 'Download date of logger % in session % is earlier than startup date', $1, $2;
END;]]></definition>
</function>

<function name="fn_raise_deployment_date_exception"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="logger_id">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="session_id">
		<type name="integer" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
  RAISE EXCEPTION 'Deployment date of logger % in session % is earlier than startup date', $1, $2;
END;]]></definition>
</function>

<function name="fn_record_metadata_last_updated"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	NEW.updated_by := current_user;
	NEW.last_updated := now();

RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_record_metadata_last_updated" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="imports.metadata_import">
		<function signature="functions.fn_record_metadata_last_updated()"/>
</trigger>

<function name="fn_record_logging_session_last_updated"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
NEW.last_updated := now();
NEW.updated_by := current_user;
RETURN NEW;
END;]]></definition>
</function>

<trigger name="tr_update_session_last_modified" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="loggers.logging_session">
		<function signature="functions.fn_record_logging_session_last_updated()"/>
</trigger>

<index name="postable_logger_model" table="positions.postable"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="logger_model"/>
		</idxelement>
</index>

<function name="fn_update_postable_logging_session"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
UPDATE positions.postable pos
SET session_id = foo.session_id 
FROM (SELECT ls.session_id, p.id
FROM loggers.logging_session ls, loggers.logger_info li, positions.postable p
WHERE p.logger_id = li.logger_serial_no
AND p.logger_model = li.logger_model
AND li.logger_id = ls.logger_id
AND p.year_tracked = ls.year_tracked) foo
WHERE pos.id = foo.id;
RETURN NULL;
END;]]></definition>
</function>

<schema name="seatrack" rect-visible="true" fill-color="#e1e1e1">
	<role name="postgres"/>
	<comment><![CDATA[temporary for importing from existing database]]></comment>
</schema>

<function name="fn_delete_individ_info_on_delete_individ_status"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="functions"/>
	<role name="admin"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN

DELETE FROM individuals.individ_info
WHERE ring_number NOT IN (SELECT DISTINCT ring_number FROM individuals.individ_status) AND
euring_code NOT IN (SELECT DISTINCT ring_number FROM individuals.individ_status);

RETURN NULL;]]></definition>
</function>

<trigger name="tr_delete_individ_info_on_delete_individ_status" firing-type="AFTER" per-line="false" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="individuals.individ_status">
		<function signature="functions.fn_delete_individ_info_on_delete_individ_status()"/>
</trigger>

<schema name="restricted" rect-visible="true" fill-color="#e1e1e1">
	<role name="admin"/>
</schema>

<view name="ftp_credentials">
	<schema name="restricted"/>
	<role name="admin"/>
	<position x="0" y="0"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT ON (foo.username) foo.username::text AS "User",
    "right"(foo.rolpassword, '-3'::integer) AS "Password",
    foo.username::character varying AS "Uid",
        CASE
            WHEN foo.groups ~~ '%writer'::text THEN 'write'::character varying
            WHEN foo.groups ~~ 'admin'::text THEN 'write'::character varying
            ELSE 'read'::character varying
        END AS "Gid",
    '/data/local/ftp'::text AS "Dir"
   FROM ( SELECT pg_authid.rolname AS username,
            pg_roles.rolname AS groups,
            pg_authid.rolpassword
           FROM pg_user
             JOIN pg_auth_members ON pg_user.usesysid = pg_auth_members.member
             JOIN pg_roles ON pg_roles.oid = pg_auth_members.roleid
             JOIN pg_authid ON pg_user.usename = pg_authid.rolname
          WHERE pg_authid.rolcanlogin IS TRUE) foo
  ORDER BY foo.username;
]]></expression>
	</reference>
</view>

<view name="export">
	<schema name="views"/>
	<role name="admin"/>
	<position x="2097.14" y="1495.71"/>
	<reference>
		<expression><![CDATA[ SELECT postable.id,
    postable.date_time,
    postable.logger,
    postable.logger_id,
    postable.logger_model,
    postable.year_tracked,
    postable.year_deployed,
    postable.year_retrieved,
    postable.ring_number,
    postable.euring_code,
    postable.species,
    postable.colony,
    postable.lon_raw,
    postable.lat_raw,
    postable.lon_smooth1,
    postable.lat_smooth1,
    postable.lon_smooth2,
    postable.lat_smooth2,
    postable.disttocol_s2,
    postable.eqfilter1,
    postable.eqfilter2,
    postable.eqfilter3,
    postable.lat_smooth2_eqfilt3,
    postable.sex,
    postable.morph,
    postable.subspecies,
    postable.age,
    postable.col_lon,
    postable.col_lat,
    postable.tfirst,
    postable.tsecond,
    postable.twl_type,
    postable.conf,
    postable.sun,
    postable.software,
    postable.light_threshold,
    postable.analyzer,
    postable.data_responsible,
    postable.logger_yeartracked,
    postable.posdata_file,
    postable.import_date,
    postable.data_version,
    postable.database_version,
    subspecies.species_name_latin,
    subspecies.sub_species
   FROM positions.postable
     LEFT JOIN metadata.subspecies ON postable.species::text = subspecies.species_name_eng AND COALESCE(postable.subspecies, ''::character varying)::text = COALESCE(subspecies.sub_species, ''::text);
]]></expression>
	</reference>
</view>

<table name="colony">
	<schema name="metadata"/>
	<role name="admin"/>
	<position x="80" y="760"/>
	<column name="id" not-null="true" default-value="uuid_generate_v1()">
		<type name="uuid" length="0"/>
	</column>
	<column name="lat">
		<type name="double precision" length="0"/>
	</column>
	<column name="lon">
		<type name="double precision" length="0"/>
	</column>
	<column name="colony_int_name">
		<type name="text" length="0"/>
	</column>
	<column name="colony_nat_name">
		<type name="text" length="0"/>
	</column>
	<column name="geom">
		<type name="geometry" length="0" spatial-type="POINT" variation="0" srid="4326"/>
	</column>
	<constraint name="colony_pk" type="pk-constr" table="metadata.colony">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="colony_int_name_unique" type="uq-constr" table="metadata.colony">
		<columns names="colony_int_name" ref-type="src-columns"/>
	</constraint>
	<constraint name="colony_nat_unique" type="uq-constr" table="metadata.colony">
		<columns names="colony_nat_name" ref-type="src-columns"/>
	</constraint>
	<initial-data>
<![CDATA[lat•lon•colony_int_name•colony_nat_name⸣
62.436•5.874•Runde and Aalesund•Runde and Ålesund⸣
69.065•15.170•Anda•Anda⸣
74.503•18.956•Bear Island•Bjørnøya⸣
69.635•18.848•Grindoya•Grindøya⸣
71.113•24.732•Hjelmsoya•Hjelmsøya⸣
60.668•4.749•Hordaland•Hordaland⸣
70.383•31.150•Hornoya•Hornøya⸣
78.253•15.508•Isfjorden•Isfjorden⸣
70.921•-8.718•Jan Mayen•Jan Mayen⸣
67.447•11.910•Rost•Røst⸣
66.585•12.229•Selvaer•Selvær⸣
65.320•11.630•Horsvaer•Horsvær⸣
65.202•10.995•Sklinna•Sklinna⸣
78.900•12.217•Kongsfjorden•Kongsfjorden⸣
69.031•16.905•Lemmingsvaer•Lemmingsvær⸣
70.358•21.398•Loppa•Loppa⸣
58.008•7.368•Mandal and Lindesnes•Mandal and Lindesnes⸣
79.585•18.459•Alkefjellet•Alkefjellet⸣
59.150•5.174•Jarsteinen•Jarsteinen⸣
65.081•-22.740•Breidafjordur•Breiðafjörður⸣
65.004•-23.368•Melrakkaey•Melrakkaey⸣
63.968•-22.221•Reykjanes•Reykjanes⸣
66.180•-15.985•Langanes and Skjalfandi•Langanes and Skjálfandi⸣
66.529•-17.992•Grimsey•Grímsey⸣
65.707•-18.135•Eyjafjordur•Eyjafjörður⸣
64.588•-14.172•Papey•Papey⸣
61.950•-6.798•Faroe Islands•Føroyar⸣
56.186•-2.558•Isle of May•Isle of May⸣
59.142•-3.115•Eynhallow•Eynhallow⸣
80.144•51.468•Franz Josef Land•Zemlya Frantsa-Iosifa⸣
69.583•32.937•Cape Gorodetskiy•Gorodetskye ptich`i bazary⸣
69.151•35.948•Cape Krutik•Mys Krutik⸣
68.748•37.570•Seven Islands•Sem' Ostrovov⸣
77.069•67.642•Oranskie Islands•Oranskie Ostrova⸣
70.593•55.021•Cape Sakhanin•Mys Sakhanina⸣
65.048•35.786•Solovetsky archipelago•Solovetskiye Ostrova⸣
77.000•15.550•Hornsund•Hornsund⸣
65.54•-13.78•Hafnarholmi•Hafnarhólmi⸣
57.158259•9.025082•Bulbjerg•Bulbjerg⸣
59.512853•-1.650526•Fair Isle•Fair Isle⸣
64.1716•9.4078•Halten•Halten⸣
73.716698•-56.6633301•Kippaku•Kippaku⸣
55.29777•-6.28041•Rathlin•Rathlin⸣
51.737687•-5.300236•Skomer•Skomer⸣
69.8•-51.21•Ritenbenk•Ritenbenk⸣
64.6522•-50.59185•Nuuk•Nuuk⸣
70.68996946•23.5989887•Melkoya•Melkøya⸣
65•10•testcolony•testcolonü]]>
	</initial-data>
</table>

<trigger name="tr_insert_colony_geom" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="metadata.colony">
		<function signature="functions.fn_update_colony_geom()"/>
</trigger>

<trigger name="tr_update_colony_geom" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="metadata.colony">
		<function signature="functions.fn_update_colony_geom()"/>
		<columns names="lat,lon"/>
</trigger>

<constraint name="logger_model_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.logger_models" table="loggers.logger_info">
	<columns names="producer,logger_model" ref-type="src-columns"/>
	<columns names="producer,model" ref-type="dst-columns"/>
</constraint>

<constraint name="logger_mod_prod_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.logger_producers" table="metadata.logger_models">
	<columns names="producer" ref-type="src-columns"/>
	<columns names="producer" ref-type="dst-columns"/>
</constraint>

<constraint name="startup_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="RESTRICT" del-action="RESTRICT" ref-table="loggers.startup" table="loggers.allocation">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="species_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.species" table="loggers.allocation">
	<columns names="intended_species" ref-type="src-columns"/>
	<columns names="species_name_eng" ref-type="dst-columns"/>
</constraint>

<constraint name="allocation_people_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.people" table="loggers.allocation">
	<columns names="intended_deployer" ref-type="src-columns"/>
	<columns names="name" ref-type="dst-columns"/>
</constraint>

<constraint name="allocation_logger_id_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.logger_info" table="loggers.allocation">
	<columns names="logger_id" ref-type="src-columns"/>
	<columns names="logger_id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_allocation_session_id" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="loggers.logging_session" table="loggers.allocation">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="deployment_logging_session_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.deployment" table="loggers.logging_session">
	<columns names="deployment_id" ref-type="src-columns"/>
	<columns names="deployment_id" ref-type="dst-columns"/>
</constraint>

<constraint name="retrieval_logging_session_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.retrieval" table="loggers.logging_session">
	<columns names="retrieval_id" ref-type="src-columns"/>
	<columns names="retrieval_id" ref-type="dst-columns"/>
</constraint>

<constraint name="logging_session_startup_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.startup" table="loggers.logging_session">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="logging_session_individ_id_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="individuals.individ_info" table="loggers.logging_session">
	<columns names="individ_id" ref-type="src-columns"/>
	<columns names="individ_id" ref-type="dst-columns"/>
</constraint>

<constraint name="logging_session_logger_id_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.logger_info" table="loggers.logging_session">
	<columns names="logger_id" ref-type="src-columns"/>
	<columns names="logger_id" ref-type="dst-columns"/>
		<comment><![CDATA[Could be redundant since we have this key on startup. ]]></comment>
</constraint>

<constraint name="colony_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.colony" table="metadata.location">
	<columns names="colony_nat_name" ref-type="src-columns"/>
	<columns names="colony_nat_name" ref-type="dst-columns"/>
</constraint>

<constraint name="location_colony_int_name_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.colony" table="metadata.location">
	<columns names="colony_int_name" ref-type="src-columns"/>
	<columns names="colony_int_name" ref-type="dst-columns"/>
</constraint>

<constraint name="species_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.species" table="loggers.deployment">
	<columns names="deployment_species" ref-type="src-columns"/>
	<columns names="species_name_eng" ref-type="dst-columns"/>
</constraint>

<constraint name="location_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.location" table="loggers.deployment">
	<columns names="deployment_location" ref-type="src-columns"/>
	<columns names="location_name" ref-type="dst-columns"/>
</constraint>

<constraint name="logger_fate_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.logger_fate" table="loggers.deployment">
	<columns names="logger_fate" ref-type="src-columns"/>
	<columns names="logger_fate" ref-type="dst-columns"/>
</constraint>

<constraint name="individ_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="individuals.individ_info" table="loggers.deployment">
	<columns names="individ_id" ref-type="src-columns"/>
	<columns names="individ_id" ref-type="dst-columns"/>
</constraint>

<constraint name="deployment_location_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.location" table="loggers.deployment">
	<columns names="deployment_location" ref-type="src-columns"/>
	<columns names="location_name" ref-type="dst-columns"/>
</constraint>

<constraint name="deployment_logging_session_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="loggers.logging_session" table="loggers.deployment">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="deployment_logger_mount_method_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.mounting_types" table="loggers.deployment">
	<columns names="logger_mount_method" ref-type="src-columns"/>
	<columns names="logger_mount_method" ref-type="dst-columns"/>
</constraint>

<constraint name="sexing_method_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.sexing_method" table="individuals.individ_info">
	<columns names="sexing_method" ref-type="src-columns"/>
	<columns names="method" ref-type="dst-columns"/>
</constraint>

<constraint name="sex_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.sex" table="individuals.individ_info">
	<columns names="sex" ref-type="src-columns"/>
	<columns names="sex" ref-type="dst-columns"/>
</constraint>

<constraint name="species_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="metadata.subspecies" table="individuals.individ_info">
	<columns names="species,subspecies" ref-type="src-columns"/>
	<columns names="species_name_eng,sub_species" ref-type="dst-columns"/>
</constraint>

<constraint name="status_logging_session_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.startup" table="individuals.individ_status">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="status_logger_id_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.logger_info" table="individuals.individ_status">
	<columns names="logger_id" ref-type="src-columns"/>
	<columns names="logger_id" ref-type="dst-columns"/>
</constraint>

<constraint name="status_breeding_stage_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.breeding_stages" table="individuals.individ_status">
	<columns names="breeding_stage" ref-type="src-columns"/>
	<columns names="breeding_stage" ref-type="dst-columns"/>
</constraint>

<constraint name="breeding_success_criterion_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.breeding_success_criterion" table="individuals.individ_status">
	<columns names="breeding_success_criterion" ref-type="src-columns"/>
	<columns names="breeding_success_criterion" ref-type="dst-columns"/>
</constraint>

<constraint name="individ_status_data_responsible_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.people" table="individuals.individ_status">
	<columns names="data_responsible" ref-type="src-columns"/>
	<columns names="name" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_species" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.subspecies" table="individuals.individ_status">
	<columns names="species,subspecies" ref-type="src-columns"/>
	<columns names="species_name_eng,sub_species" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_sex" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.sex" table="individuals.individ_status">
	<columns names="sex" ref-type="src-columns"/>
	<columns names="sex" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_sexing_method" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.sexing_method" table="individuals.individ_status">
	<columns names="sexing_method" ref-type="src-columns"/>
	<columns names="method" ref-type="dst-columns"/>
</constraint>

<constraint name="individ_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="individuals.individ_info" table="loggers.retrieval">
	<columns names="individ_id" ref-type="src-columns"/>
	<columns names="individ_id" ref-type="dst-columns"/>
</constraint>

<constraint name="location_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.location" table="loggers.retrieval">
	<columns names="retrieval_location" ref-type="src-columns"/>
	<columns names="location_name" ref-type="dst-columns"/>
</constraint>

<constraint name="retrieval_logging_session_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="loggers.logging_session" table="loggers.retrieval">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="retrieval_type_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.retrieval_type" table="loggers.retrieval">
	<columns names="retrieval_type" ref-type="src-columns"/>
	<columns names="type" ref-type="dst-columns"/>
</constraint>

<constraint name="shutdown_startup_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="loggers.startup" table="loggers.shutdown">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="download_type_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.download_types" table="loggers.shutdown">
	<columns names="download_type" ref-type="src-columns"/>
	<columns names="download_type" ref-type="dst-columns"/>
</constraint>

<constraint name="shutdown_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.shutdown" table="loggers.file_archive">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="events_deployment_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.deployment" table="loggers.events">
	<columns names="deployment_id" ref-type="src-columns"/>
	<columns names="deployment_id" ref-type="dst-columns"/>
</constraint>

<constraint name="events_retrieval_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.retrieval" table="loggers.events">
	<columns names="retrieval_id" ref-type="src-columns"/>
	<columns names="retrieval_id" ref-type="dst-columns"/>
</constraint>

<constraint name="logger_year_tracked_logging_session_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.logging_session" table="positions.logger_year_tracked">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="temp_session_id_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="loggers.startup" table="activity.temperature">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="salinity_session_id_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="loggers.startup" table="activity.salinity">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="logging_modes_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="RESTRICT" del-action="RESTRICT" ref-table="metadata.logging_modes" table="loggers.startup">
	<columns names="logging_mode" ref-type="src-columns"/>
	<columns names="mode" ref-type="dst-columns"/>
</constraint>

<constraint name="people_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.people" table="loggers.startup">
	<columns names="started_by" ref-type="src-columns"/>
	<columns names="name" ref-type="dst-columns"/>
</constraint>

<constraint name="startup_logger_id_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="loggers.logger_info" table="loggers.startup">
	<columns names="logger_id" ref-type="src-columns"/>
	<columns names="logger_id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_startup_session_id" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="loggers.logging_session" table="loggers.startup">
	<columns names="session_id" ref-type="src-columns"/>
	<columns names="session_id" ref-type="dst-columns"/>
</constraint>

<constraint name="observation_individ_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="individuals.individ_info" table="individuals.observations">
	<columns names="individ_id" ref-type="src-columns"/>
	<columns names="individ_id" ref-type="dst-columns"/>
</constraint>

<constraint name="logger_model_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="RESTRICT" ref-table="metadata.logger_models" table="metadata.logger_files">
	<columns names="logger_model,logger_producer" ref-type="src-columns"/>
	<columns names="model,producer" ref-type="dst-columns"/>
</constraint>

<constraint name="logger_retrieved_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="loggers.logger_info" table="imports.metadata_import">
	<columns names="logger_id_retrieved,logger_model_retrieved" ref-type="src-columns"/>
	<columns names="logger_serial_no,logger_model" ref-type="dst-columns"/>
</constraint>

<constraint name="logger_deployed_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="loggers.logger_info" table="imports.metadata_import">
	<columns names="logger_id_deployed,logger_model_deployed" ref-type="src-columns"/>
	<columns names="logger_serial_no,logger_model" ref-type="dst-columns"/>
</constraint>

<constraint name="species_fk" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="metadata.subspecies" table="imports.metadata_import">
	<columns names="species,subspecies" ref-type="src-columns"/>
	<columns names="species_name_eng,sub_species" ref-type="dst-columns"/>
</constraint>

<constraint name="sex_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="metadata.sex" table="imports.metadata_import">
	<columns names="sex" ref-type="src-columns"/>
	<columns names="sex" ref-type="dst-columns"/>
</constraint>

<constraint name="sexing_method_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="metadata.sexing_method" table="imports.metadata_import">
	<columns names="sexing_method" ref-type="src-columns"/>
	<columns names="method" ref-type="dst-columns"/>
</constraint>

<constraint name="breeding_stages_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="metadata.breeding_stages" table="imports.metadata_import">
	<columns names="breeding_stage" ref-type="src-columns"/>
	<columns names="breeding_stage" ref-type="dst-columns"/>
</constraint>

<constraint name="breeding_success_criterion_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="metadata.breeding_success_criterion" table="imports.metadata_import">
	<columns names="breeding_success_criterion" ref-type="src-columns"/>
	<columns names="breeding_success_criterion" ref-type="dst-columns"/>
</constraint>

<constraint name="colony_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="RESTRICT" ref-table="metadata.location" table="imports.metadata_import">
	<columns names="colony" ref-type="src-columns"/>
	<columns names="location_name" ref-type="dst-columns"/>
</constraint>

<constraint name="data_responsible_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="metadata.people" table="imports.metadata_import">
	<columns names="data_responsible" ref-type="src-columns"/>
	<columns names="name" ref-type="dst-columns"/>
</constraint>

<constraint name="logger_mount_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="metadata.mounting_types" table="imports.metadata_import">
	<columns names="logger_mount_method" ref-type="src-columns"/>
	<columns names="logger_mount_method" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_logger_info_logger_models" type="relfk"
	 src-table="loggers.logger_info"
	 dst-table="metadata.logger_models" reference-fk="logger_model_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_allocation_startup" type="relfk"
	 src-table="loggers.allocation"
	 dst-table="loggers.startup" reference-fk="startup_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_allocation_people" type="relfk"
	 src-table="loggers.allocation"
	 dst-table="metadata.people" reference-fk="allocation_people_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_allocation_logger_info" type="relfk"
	 src-table="loggers.allocation"
	 dst-table="loggers.logger_info" reference-fk="allocation_logger_id_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_logging_session_deployment" type="relfk"
	 src-table="loggers.logging_session"
	 dst-table="loggers.deployment" reference-fk="deployment_logging_session_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_logging_session_retrieval" type="relfk"
	 src-table="loggers.logging_session"
	 dst-table="loggers.retrieval" reference-fk="retrieval_logging_session_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_logging_session_startup" type="relfk"
	 src-table="loggers.logging_session"
	 dst-table="loggers.startup" reference-fk="logging_session_startup_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_logging_session_individ_info" type="relfk"
	 src-table="loggers.logging_session"
	 dst-table="individuals.individ_info" reference-fk="logging_session_individ_id_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_logging_session_logger_info" type="relfk"
	 src-table="loggers.logging_session"
	 dst-table="loggers.logger_info" reference-fk="logging_session_logger_id_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_location_colony" type="relfk"
	 src-table="metadata.location"
	 dst-table="metadata.colony" reference-fk="colony_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_deployment_location" type="relfk"
	 src-table="loggers.deployment"
	 dst-table="metadata.location" reference-fk="location_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_deployment_logger_fate" type="relfk"
	 src-table="loggers.deployment"
	 dst-table="metadata.logger_fate" reference-fk="logger_fate_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_deployment_individ_info" type="relfk"
	 src-table="loggers.deployment"
	 dst-table="individuals.individ_info" reference-fk="individ_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_deployment_mounting_types" type="relfk"
	 src-table="loggers.deployment"
	 dst-table="metadata.mounting_types" reference-fk="deployment_logger_mount_method_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_info_sexing_method" type="relfk"
	 src-table="individuals.individ_info"
	 dst-table="metadata.sexing_method" reference-fk="sexing_method_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_info_sex" type="relfk"
	 src-table="individuals.individ_info"
	 dst-table="metadata.sex" reference-fk="sex_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_status_startup" type="relfk"
	 src-table="individuals.individ_status"
	 dst-table="loggers.startup" reference-fk="status_logging_session_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_status_logger_info" type="relfk"
	 src-table="individuals.individ_status"
	 dst-table="loggers.logger_info" reference-fk="status_logger_id_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_status_breeding_stages" type="relfk"
	 src-table="individuals.individ_status"
	 dst-table="metadata.breeding_stages" reference-fk="status_breeding_stage_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_retrieval_individ_info" type="relfk"
	 src-table="loggers.retrieval"
	 dst-table="individuals.individ_info" reference-fk="individ_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_retrieval_location" type="relfk"
	 src-table="loggers.retrieval"
	 dst-table="metadata.location" reference-fk="location_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_shutdown_startup" type="relfk"
	 src-table="loggers.shutdown"
	 dst-table="loggers.startup" reference-fk="shutdown_startup_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_file_archive_shutdown" type="relfk"
	 src-table="loggers.file_archive"
	 dst-table="loggers.shutdown" reference-fk="shutdown_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_events_deployment" type="relfk"
	 src-table="loggers.events"
	 dst-table="loggers.deployment" reference-fk="events_deployment_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_events_retrieval" type="relfk"
	 src-table="loggers.events"
	 dst-table="loggers.retrieval" reference-fk="events_retrieval_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_logger_year_tracked_logging_session" type="relfk"
	 src-table="positions.logger_year_tracked"
	 dst-table="loggers.logging_session" reference-fk="logger_year_tracked_logging_session_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_temperature_startup" type="relfk"
	 src-table="activity.temperature"
	 dst-table="loggers.startup" reference-fk="temp_session_id_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_salinity_startup" type="relfk"
	 src-table="activity.salinity"
	 dst-table="loggers.startup" reference-fk="salinity_session_id_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_startup_logging_modes" type="relfk"
	 src-table="loggers.startup"
	 dst-table="metadata.logging_modes" reference-fk="logging_modes_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_startup_people" type="relfk"
	 src-table="loggers.startup"
	 dst-table="metadata.people" reference-fk="people_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_startup_logger_info" type="relfk"
	 src-table="loggers.startup"
	 dst-table="loggers.logger_info" reference-fk="startup_logger_id_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_observations_individ_info" type="relfk"
	 src-table="individuals.observations"
	 dst-table="individuals.individ_info" reference-fk="observation_individ_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_logger_files_logger_models" type="relfk"
	 src-table="metadata.logger_files"
	 dst-table="metadata.logger_models" reference-fk="logger_model_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_logger_models_logger_producers" type="relfk"
	 src-table="metadata.logger_models"
	 dst-table="metadata.logger_producers" reference-fk="logger_mod_prod_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_retrieval_retrieval_type" type="relfk"
	 src-table="loggers.retrieval"
	 dst-table="metadata.retrieval_type" reference-fk="retrieval_type_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_shutdown_download_types" type="relfk"
	 src-table="loggers.shutdown"
	 dst-table="metadata.download_types" reference-fk="download_type_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_status_breeding_success_criterion" type="relfk"
	 src-table="individuals.individ_status"
	 dst-table="metadata.breeding_success_criterion" reference-fk="breeding_success_criterion_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_status_people" type="relfk"
	 src-table="individuals.individ_status"
	 dst-table="metadata.people" reference-fk="individ_status_data_responsible_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_logger_info" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="loggers.logger_info" reference-fk="logger_retrieved_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_deployment_species" type="relfk"
	 src-table="loggers.deployment"
	 dst-table="metadata.species" reference-fk="species_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_allocation_species" type="relfk"
	 src-table="loggers.allocation"
	 dst-table="metadata.species" reference-fk="species_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_info_subspecies" type="relfk"
	 src-table="individuals.individ_info"
	 dst-table="metadata.subspecies" reference-fk="species_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_subspecies" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="metadata.subspecies" reference-fk="species_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_sex" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="metadata.sex" reference-fk="sex_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_sexing_method" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="metadata.sexing_method" reference-fk="sexing_method_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_breeding_stages" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="metadata.breeding_stages" reference-fk="breeding_stages_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_breeding_success_criterion" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="metadata.breeding_success_criterion" reference-fk="breeding_success_criterion_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_people" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="metadata.people" reference-fk="data_responsible_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_mounting_types" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="metadata.mounting_types" reference-fk="logger_mount_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_metadata_import_location" type="relfk"
	 src-table="imports.metadata_import"
	 dst-table="metadata.location" reference-fk="colony_fk"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_status_subspecies" type="relfk"
	 src-table="individuals.individ_status"
	 dst-table="metadata.subspecies" reference-fk="fk_species"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_status_sex" type="relfk"
	 src-table="individuals.individ_status"
	 dst-table="metadata.sex" reference-fk="fk_sex"
	 src-required="false" dst-required="false"/>

<relationship name="rel_individ_status_sexing_method" type="relfk"
	 src-table="individuals.individ_status"
	 dst-table="metadata.sexing_method" reference-fk="fk_sexing_method"
	 src-required="false" dst-required="false"/>

<relationship name="rel_allocation_logging_session" type="relfk"
	 src-table="loggers.allocation"
	 dst-table="loggers.logging_session" reference-fk="fk_allocation_session_id"
	 src-required="false" dst-required="false"/>

<permission>
	<object name="seatrack" type="database"/>
	<roles names="seatrack_reader"/>
	<privileges connect="true"/>
</permission>
<permission>
	<object name="seatrack" type="database"/>
	<roles names="seatrack_writer"/>
	<privileges connect="true"/>
</permission>
<permission>
	<object name="metadata" type="schema"/>
	<roles names="seatrack_reader"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="metadata" type="schema"/>
	<roles names="seatrack_writer"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="activity.temperature" type="table"/>
	<roles names="seatrack_reader"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="activity.temperature" type="table"/>
	<roles names="seatrack_writer"/>
	<privileges select="true" delete="true" insert="true" update="true" trigger="true"/>
</permission>
<permission>
	<object name="views.active_logging_sessions" type="view"/>
	<roles names="seatrack_reader"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="views.closed_sessions_not_shutdown" type="view"/>
	<roles names="seatrack_reader"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="views" type="schema"/>
	<roles names="seatrack_reader"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="activity" type="schema"/>
	<roles names="seatrack_reader"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="restricted" type="schema"/>
	<roles names="restricted"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="restricted.ftp_credentials" type="view"/>
	<roles names="restricted"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="views.export" type="view"/>
	<roles names="seatrack_reader"/>
	<privileges select="true"/>
</permission>
</dbmodel>
